<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Raspberry Pi on Docker Pirates ARMed with explosive stuff</title>
    <link>http://localhost:1313/categories/raspberry-pi/</link>
    <description>Recent content in Raspberry Pi on Docker Pirates ARMed with explosive stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Mar 2016 17:20:34 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/raspberry-pi/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Close Encounters of the Third Kind, or Microsoft Windows meets Docker ARM Containers for IoT</title>
      <link>http://localhost:1313/post/close-encounters-of-the-third-kind/</link>
      <pubDate>Tue, 29 Mar 2016 17:20:34 +0200</pubDate>
      
      <guid>http://localhost:1313/post/close-encounters-of-the-third-kind/</guid>
      <description>

&lt;p&gt;Running an ARM-based Docker container for IoT applications directly on Microsoft Windows
looks like an unbelievable &lt;strong&gt;extraterrestrial technology&lt;/strong&gt; from outer space.&lt;/p&gt;

&lt;p&gt;This cannot be true, it must be a fake, right?&lt;br /&gt;
Or, is this maybe just a &lt;strong&gt;cheap magic trick&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/close-encounters-of-the-third-kind/docker4win-arm-webpage.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Nope, believe me, that&amp;rsquo;s really true&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;behind-the-scenes:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Behind the scenes&lt;/h2&gt;

&lt;p&gt;As I showed in my last blog post about the &lt;a href=&#34;http://blog.hypriot.com/post/first-touch-down-with-docker-for-mac/&#34;&gt;First Touch Down with Docker for Mac&lt;/a&gt;,
&amp;ldquo;Docker for Mac&amp;rdquo; uses an Alpine Linux VM under the hood with the capability of emulating
ARM binaries on Intel CPUs. Because of &amp;ldquo;Docker for Windows&amp;rdquo; uses exactly the same
Alpine Linux in a Hyper-V virtual machine, this should work on Windows 10, too.&lt;/p&gt;

&lt;p&gt;The only problem here is, that the bind-mounting of a single binary doesn&amp;rsquo;t work
right now on Windows. I guess this will be fixed in a later release for sure. But
we can easily prepare an ARM-based Docker container to make the magic happen.&lt;/p&gt;

&lt;p&gt;We just have to put the &lt;a href=&#34;https://en.wikipedia.org/wiki/QEMU&#34;&gt;QEMU&lt;/a&gt; emulator binary
into the Docker container, and as long as we
place it at the correct path &lt;code&gt;/usr/bin/qemu-arm-static&lt;/code&gt;, this should work. The easiest
way to include the binary to the correct folder is to create a tar archive and use
the ADD command in the Dockerfile.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar vtf qemu-arm-static.tar
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/
drwxr-xr-x  0 dieter staff       0 Mar 28 18:34 usr/bin/
-rwxr-xr-x  0 dieter staff 2899840 Mar 28 18:34 usr/bin/qemu-arm-static
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dockerfile:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;FROM hypriot/rpi-busybox-httpd
ADD qemu-arm-static.tar /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this easy preparation we&amp;rsquo;re able to start an ARM-based Docker container on
Windows 10 with two steps only.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Create the modified Docker image&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t rpi-busybox-httpd .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; Start the QEMU-enabled Docker container&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -d -p 80:80 rpi-busybox-httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here in this screenshot you can see all the necessary steps we need, there is really
nothing else to do.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/close-encounters-of-the-third-kind/docker4win-arm-container.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Voilà&lt;/strong&gt; - that was the magic trick which can be applied to almost all ARM-based Docker
images to make them run in &amp;ldquo;Docker for Windows&amp;rdquo; and &amp;ldquo;Docker for Mac&amp;rdquo; even on an Intel-based
CPU architecture.&lt;/p&gt;

&lt;h2 id=&#34;watch-the-results:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Watch the results&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Docker for Windows&amp;rdquo; publishes the Docker Engine network with the local network name
&lt;code&gt;docker&lt;/code&gt;. Thus to access the ARM web server, which is running inside of a Linux container,
 we just have to point our preferred web browser to &lt;code&gt;http://docker/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/close-encounters-of-the-third-kind/docker4win-arm-webpage2.jpg&#34; alt=&#34;Docker for Windows&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;key-takeaways:41ce06d9c70eae57025ae829633db5ae&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Docker for Windows&amp;rdquo; uses Windows native hypervisor Hyper-V&lt;/li&gt;
&lt;li&gt;the Docker Engine is running in a tiny Alpine Linux VM&lt;/li&gt;
&lt;li&gt;ARM-based Docker containers can be easily enabled with QEMU emulator&lt;/li&gt;
&lt;li&gt;Docker works great on Windows 10&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Are you curious now and want to get in touch with &amp;ldquo;Docker for Windows&amp;rdquo; by yourself?
Then you should register for the Docker BETA program at &lt;a href=&#34;https://beta.docker.com&#34;&gt;https://beta.docker.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Your No. 1 source for Docker on ARM</title>
      <link>http://localhost:1313/post/your-number-one-source-for-docker-on-arm/</link>
      <pubDate>Mon, 28 Mar 2016 22:00:00 +0100</pubDate>
      
      <guid>http://localhost:1313/post/your-number-one-source-for-docker-on-arm/</guid>
      <description>&lt;p&gt;Besides our &lt;a href=&#34;https://blog.hypriot.com/downloads/&#34;&gt;Download section&lt;/a&gt; we do have another source for getting the latest and greatest Docker for ARM.&lt;br /&gt;
It is a debian package repository hosted at &lt;a href=&#34;https://packagecloud.io/&#34;&gt;packagecloud.io&lt;/a&gt; that contains lots of the stuff from our Download section.&lt;/p&gt;

&lt;p&gt;Despite having a package repository for a couple of months now, it seems many people do not know it.
I guess that&amp;rsquo;s our own fault because we never spoke about it - we only added it to our prepared SD card images. :)
Installing or updating Docker or other Docker goodies like Docker-Compose from this repository can be done by a simple &lt;code&gt;apt-get install&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this post I gonna show you what you need to know to get started with this repository.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/packagecloud/packagecloud_io_wide.jpg&#34; alt=&#34;Raspberry Pi Workshop in Brussels&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Packagecloud.io is a really great service for hosting different types of packages (DEBs, RPMs, Ruby Gems).
You get detailed download/usage statistics and can manage all your packages easily with a Web-GUI or with an API.&lt;/p&gt;

&lt;p&gt;The last point was what convinced us to use packagecloud.io as it allows us to upload our packages directly from our Continuous Integration systems.
Many popular CI systems offer build-in packagecloud support - for instance Travis or Circle-CI.&lt;/p&gt;

&lt;p&gt;Our packagecloud repository is conveniently named &amp;ldquo;Schatzkiste&amp;rdquo; and supports Debian-based Linux distributions.&lt;/p&gt;

&lt;p&gt;To use it you need to configure &amp;lsquo;apt&amp;rsquo; first by executing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -s https://packagecloud.io/install/repositories/Hypriot/Schatzkiste/script.deb.sh | sudo bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to know what this script does you can look up the &lt;a href=&#34;https://packagecloud.io/Hypriot/Schatzkiste/install&#34;&gt;source of this script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It installs &amp;lsquo;apt-transport-https&amp;rsquo; for connecting securely to our repository, adds the packagecloud GPG key to &amp;lsquo;apt&amp;rsquo; and then adds our &amp;lsquo;Schatzkiste&amp;rsquo;-repository sources to &amp;lsquo;/etc/apt/sources.list.d/Hypriot_Schatzkiste.list&amp;rsquo;.&lt;br /&gt;
Afterwards it updates the package sources via &amp;lsquo;apt-get update&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;From there you are ready to search for the latest Docker via&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-cache madison docker-hypriot
docker-hypriot |   1.10.3-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |   1.10.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.9.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.9.0-2 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.3-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.8.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.7.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.2-2 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.2-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.1-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.6.0-1 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
docker-hypriot |    1.5.0-7 | https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy/main armhf Packages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;lsquo;apt-cache madison&amp;rsquo; will list all the available version for package &amp;lsquo;docker-hypriot&amp;rsquo; and as you can see the latest Docker 1.10.3 is already there, too.&lt;/p&gt;

&lt;p&gt;Install it with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ apt-get install docker-hypriot=1.10.3-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I want to close this blog post with a huge thank you to the packagecloud.io guys as they are hosting our packages for free.&lt;/p&gt;

&lt;p&gt;I highly recommend their service as it can be so tedious and time-consuming to setup your own repository properly - I have been there myself.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First Touch Down with Docker for Mac</title>
      <link>http://localhost:1313/post/first-touch-down-with-docker-for-mac/</link>
      <pubDate>Sun, 27 Mar 2016 18:30:29 +0200</pubDate>
      
      <guid>http://localhost:1313/post/first-touch-down-with-docker-for-mac/</guid>
      <description>

&lt;p&gt;A few days ago, Docker has announced a closed BETA program for their new
applications &amp;ldquo;Docker for Mac&amp;rdquo; and &amp;ldquo;Docker for Windows&amp;rdquo;. These apps are meant to
simplify the usage of Docker containers for every developer even more. They try
to lower the barrier to install and use Docker on your desktop and laptop computers
for both Mac and Windows users.&lt;/p&gt;

&lt;p&gt;As soon as I received the first rumors that there is a special feature built-in,
which should also simplify the developers workflow for IoT applications, I was getting
totally thrilled and registered immediately for the BETA program. It was really hard
to wait for, but luckily I&amp;rsquo;ve received an email with my BETA invitation and access
token within a few hours only.&lt;/p&gt;

&lt;p&gt;Here I&amp;rsquo;d like to give you a first insight view how to install and use &amp;ldquo;Docker for Mac&amp;rdquo;
with a basic walk-through on my MacBook Pro running the very latest OS X 10.11.4.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-copy-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;So, please join me on this journey&amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;access-to-the-beta-program:10b72799563d55724d4550d1181f06ee&#34;&gt;Access to the BETA program&lt;/h2&gt;

&lt;p&gt;You can easily register to the Docker BETA program at &lt;a href=&#34;https://beta.docker.com&#34;&gt;https://beta.docker.com&lt;/a&gt;. Once
you&amp;rsquo;re logged in with your Docker ID (which is literally your Docker Hub user account)
you can apply for testing &amp;ldquo;Docker for Mac&amp;rdquo; and &amp;ldquo;Docker for Windows&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-apply-for-beta.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As this is a closed BETA, you&amp;rsquo;ll get on a waiting list and hopefully will be selected
soon. So, please be patient until you&amp;rsquo;ll receive an invitation email with some more
detailed instructions and a personal access key.&lt;/p&gt;

&lt;p&gt;For this blog post, I&amp;rsquo;ll show you how easy it is to install and use Docker on OS X.
And I guess, we&amp;rsquo;ll write another post later for all the curious Windows users,  too.&lt;/p&gt;

&lt;h2 id=&#34;download-and-install-docker-for-mac:10b72799563d55724d4550d1181f06ee&#34;&gt;Download and install &amp;ldquo;Docker for Mac&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;When you&amp;rsquo;re selected for the BETA, you&amp;rsquo;ll receive an email titled &amp;ldquo;Docker Private Beta&amp;rdquo;
with a link to the download page and an access key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-download-page.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Download the installer package called &amp;ldquo;Docker.dmg&amp;rdquo; to your Mac and double click it,
drag and drop the &amp;ldquo;Docker beta&amp;rdquo; app to your Applications folder.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-copy-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, from your Lauchpad you can start the &amp;ldquo;Docker beta&amp;rdquo; app directly the first time
and you can begin right away using Docker on your Mac.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-start-app.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Once you start the BETA Docker app the first time you&amp;rsquo;ll be asked to enter your
personal invite token.
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-install-01-insert-key.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Token has been accepted.
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-install-02-key-accepted.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The Docker app needs to additionally install a network helper and requests for privileges
to do so.
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-install-03-request-privileges.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Enter your credentials to grant privileged access.
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-install-04-grant-privileges.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Success, the Docker app is installed and you can easily find and access it by
clicking on the little neat whale icon.
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-install-05-tray-icon.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-docker-for-mac-the-first-time:10b72799563d55724d4550d1181f06ee&#34;&gt;Using &amp;ldquo;Docker for Mac&amp;rdquo; the first time&lt;/h2&gt;

&lt;p&gt;To use Docker we&amp;rsquo;ll just start a terminal window and use the Docker CLI to access
the local Docker Engine.&lt;/p&gt;

&lt;p&gt;First, get the version of the Docker command:
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-01-dash-v.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Determine the versions of the Docker Client and the Docker Engine:
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-02-version.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Display some more detailed informations about the installed Docker software:
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-run-docker-03-info.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;let-s-start-a-real-docker-container:10b72799563d55724d4550d1181f06ee&#34;&gt;Let&amp;rsquo;s start a real Docker container&lt;/h2&gt;

&lt;p&gt;First, we&amp;rsquo;ll check how our host operating system looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uname -a
Darwin demo.local 15.4.0 Darwin Kernel Version 15.4.0: Fri Feb 26 22:08:05 PST 2016; root:xnu-3248.40.184~3/RELEASE_X86_64 x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As already expected we see our host OS is OS X or &lt;code&gt;Darwin&lt;/code&gt; with a kernel version &lt;code&gt;15.4.0&lt;/code&gt;. Our CPU architecture is &lt;code&gt;x86_64&lt;/code&gt;, which indicates that we&amp;rsquo;re running on an Intel-based
64-bit CPU.&lt;/p&gt;

&lt;p&gt;Second, let&amp;rsquo;s start a basic Linux container and here we&amp;rsquo;re using a Debian standard distro
for now. This will take a few second because the Docker Engine has to fetch/download
the Docker image &lt;code&gt;debian&lt;/code&gt; from the Docker Hub.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -ti debian
Unable to find image &#39;debian:latest&#39; locally
latest: Pulling from library/debian
fdd5d7827f33: Pull complete
a3ed95caeb02: Pull complete
Digest: sha256:e7d38b3517548a1c71e41bffe9c8ae6d6d29546ce46bf62159837aad072c90aa
Status: Downloaded newer image for debian:latest
root@9473484ea965:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, we now do have an interactive bash prompt within a running Debian
Linux container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@9473484ea965:/# uname -a
Linux 9473484ea965 4.1.19 #1 SMP Sun Mar 20 22:13:39 UTC 2016 x86_64 GNU/Linux

root@9473484ea965:/# cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
root@9473484ea965:/#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d like to start a really tiny Linux container next, which starts even
faster than Debian. Alpine Linux is meant to be super-small and it brings a lot
of advantages into the container world, too.&lt;/p&gt;

&lt;p&gt;Starting an interactive Alpine container is pretty much the same as Debian, but we
have to use a Bourne shell instead of bash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm -ti alpine sh
Unable to find image &#39;alpine:latest&#39; locally
latest: Pulling from library/alpine
4d06f2521e4f: Pull complete
Digest: sha256:7739b19a213f3a0aa8dacbd5898c8bd467e6eaf71074296a3d75824e76257396
Status: Downloaded newer image for alpine:latest
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, this container is running on the same kernel version like before, but
uses a completely different Linux distribution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ # uname -a
Linux 411883bd07d3 4.1.19 #1 SMP Sun Mar 20 22:13:39 UTC 2016 x86_64 Linux

/ # cat /etc/os-release
NAME=&amp;quot;Alpine Linux&amp;quot;
ID=alpine
VERSION_ID=3.3.1
PRETTY_NAME=&amp;quot;Alpine Linux v3.3&amp;quot;
HOME_URL=&amp;quot;http://alpinelinux.org&amp;quot;
BUG_REPORT_URL=&amp;quot;http://bugs.alpinelinux.org&amp;quot;
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, let&amp;rsquo;s look at the details of these both Docker containers. Both are complete
Linux systems, but with a substantial difference in size.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
alpine              latest              70c557e50ed6        3 weeks ago         4.798 MB
debian              latest              f50f9524513f        3 weeks ago         125.1 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alpine Linux is damn small in size and thus the Docker images built upon Alpine
are extremely small as well, and much faster to download. Another major advantage is the
security model of Alpine Linux, which reduces the attack surface dramatically and
provides faster and easier security updates as well.&lt;/p&gt;

&lt;p&gt;This experiment with &amp;ldquo;Docker for Mac&amp;rdquo; clearly demonstrates that we can run Linux
commands inside Docker containers with a Linux OS and a recent kernel version 4.1.19. This is indeed different to our host operating system OS X.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s pure Docker container magic: running a Linux container seamlessly on our
development machine, here on a MacBook Pro (Retina, 15-inch, Mid 2014).&lt;/p&gt;

&lt;h2 id=&#34;the-magic-behind-the-scenes:10b72799563d55724d4550d1181f06ee&#34;&gt;The Magic behind the scenes&lt;/h2&gt;

&lt;p&gt;As I&amp;rsquo;ve shown you in the screenshots above, our host operating system, where the Docker
Client is running, is &lt;code&gt;darwin/amd64&lt;/code&gt; or OS X, but the Docker Engine runs on &lt;code&gt;linux/amd64&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Maybe you&amp;rsquo;re wondering how this even can be possible, right?&lt;br /&gt;
The answer is quite easy, &amp;ldquo;Docker for Mac&amp;rdquo; is shipping it&amp;rsquo;s own lightweight hypervisor
called &lt;a href=&#34;http://www.xhyve.org/&#34;&gt;xhyve&lt;/a&gt;, which itself is a port of the BSD hypervisor
&lt;a href=&#34;http://www.bhyve.org/&#34;&gt;bhyve&lt;/a&gt; to OS X.&lt;/p&gt;

&lt;p&gt;The engineers at Docker have greatly enhanced xhyve to enable an optimized usage
to efficiently run Docker containers on OS X. Inside of the xhyve hypervisor,
the Docker Engine is running in a tiny small Linux VM, which is based upon the
&lt;a href=&#34;http://www.alpinelinux.org&#34;&gt;Alpine Linux&lt;/a&gt; distribution. With this great combination
of outstanding technologies we as users get the feeling to run Docker containers
natively on our Mac.&lt;/p&gt;

&lt;p&gt;Honestly, there are even more great technical details packed into the new &amp;ldquo;Docker for Mac&amp;rdquo;
release, but we&amp;rsquo;ll keep them for a later more advanced technical blog post.&lt;/p&gt;

&lt;h2 id=&#34;there-is-another-big-arm-surprise:10b72799563d55724d4550d1181f06ee&#34;&gt;There is another big ARM surprise&lt;/h2&gt;

&lt;p&gt;With the public announcement of &amp;ldquo;Docker for Mac&amp;rdquo;, I received an &lt;a href=&#34;https://twitter.com/avsm/status/713010884596080640&#34;&gt;Easter Egg tweet&lt;/a&gt; from one
of the Docker engineers, Anil Madhavapeddy, that they&amp;rsquo;ve just included another cool
feature, which attracts me most. He promised I could even run the Docker images, which
I built for an IoT device like a Raspberry Pi on my Mac now!&lt;/p&gt;

&lt;p&gt;No way, that sounds to good to be true. And mainly because the Raspberry Pi uses
an ARM CPU, which cannot be executed on an Intel-based Mac, right?&lt;/p&gt;

&lt;p&gt;To test this, I&amp;rsquo;ll select one of my most famous Docker containers:
the webserver I&amp;rsquo;ve presented at DockerCon 2015 San Francisco, CA, last year in June (more details can be found in a dedicated blog post about the &lt;a href=&#34;http://blog.hypriot.com/post/dockercon2015/&#34;&gt;Hypriot-Demo and challenge at DockerCon 2015&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Ok, here we go. Let&amp;rsquo;s run an ARM container on a Mac:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-01.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, it doesn&amp;rsquo;t work that way&amp;hellip;&lt;br /&gt;
&amp;hellip;hmmm, but maybe with some more magic Docker spells it could be done.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-02.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And this is where all the magic happens. We&amp;rsquo;re just bind-mounting a special binary
into our original ARM-based container. Again, we don&amp;rsquo;t change the original Docker
image to get this done. In the end we are really able to run an ARM container,
which was built on a Raspberry Pi, now on an Intel-based Mac - just with the help
of some &lt;a href=&#34;https://twitter.com/quintus23m/status/713523016836231171&#34;&gt;fantastic Docker fu&lt;/a&gt;
embedded in &amp;ldquo;Docker for Mac&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-05.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As a last proof, we check with &lt;code&gt;docker ps&lt;/code&gt; that we&amp;rsquo;re running the original ARM container from June 2015:
&lt;img src=&#34;http://localhost:1313/images/first-touch-down-with-docker-for-mac/docker4mac-arm-container-04.jpg&#34; alt=&#34;Docker for Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is possible because the Docker engineers have already included the Linux kernel support
for &lt;code&gt;binfmt_misc&lt;/code&gt; into &amp;ldquo;Docker for Mac&amp;rdquo;. And as long as there is the right Qemu interpreter
&lt;code&gt;qemu-arm-static&lt;/code&gt; (which is an Intel binary itself) placed in the ARM container,
this container can be executed, or better emulated, even on a foreign CPU architecture.&lt;/p&gt;

&lt;p&gt;Now I can clearly imagine to use &amp;ldquo;Docker for Mac&amp;rdquo; as part of a new Docker-centric workflow
to build IoT containers directly on my Mac. Development and testing can be done fast and
efficiently on the developers machine and then deploying and running the IoT containers
on the target device. A few months ago such an idea has sound pretty crazy and unbelievable -
but now it&amp;rsquo;s coming true soon.&lt;/p&gt;

&lt;p&gt;Special thanks to Anil, Justin and all the other great guys at the Docker engineering
team to make this magic true.&lt;/p&gt;

&lt;h2 id=&#34;key-takeaways:10b72799563d55724d4550d1181f06ee&#34;&gt;Key Takeaways&lt;/h2&gt;

&lt;p&gt;After this first and fast walk-through, I guess you&amp;rsquo;re even more curious and you&amp;rsquo;d
like to use &amp;ldquo;Docker for Mac&amp;rdquo; by yourself. So in the meantime I&amp;rsquo;ll just summarize the
key points what impressed me most about this great new release.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;installing &amp;ldquo;Docker for Mac&amp;rdquo; was pretty easy and slick&lt;/li&gt;
&lt;li&gt;a single &lt;code&gt;.dmg&lt;/code&gt; media with 90 MByte only&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Docker for Mac&amp;rdquo; is a real native OS X application&lt;/li&gt;
&lt;li&gt;there are absolutely no other external resources or dependencies to install&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Docker for Mac&amp;rdquo; integrates perfectly into your development workflow&lt;/li&gt;
&lt;li&gt;downloading, installing and running the first Docker container takes a few minutes only&lt;/li&gt;
&lt;li&gt;for tiny containers, Alpine Linux is one of the best Linux distros&lt;/li&gt;
&lt;li&gt;ARM IoT containers can be developed and run even on a Mac&lt;/li&gt;
&lt;li&gt;&amp;hellip;much more will be revealed in later blog posts&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s build a PicoCluster for Docker Swarm</title>
      <link>http://localhost:1313/post/lets-build-a-pi-docker-picocluster/</link>
      <pubDate>Wed, 23 Mar 2016 18:40:04 +0100</pubDate>
      
      <guid>http://localhost:1313/post/lets-build-a-pi-docker-picocluster/</guid>
      <description>

&lt;p&gt;As we love to use Docker Swarm on a cluster of Raspberry Pi&amp;rsquo;s, we&amp;rsquo;d like to cover
in this hands-on tutorial how to build such a cluster easily with a hardware kit
from &lt;a href=&#34;http://picocluster.com&#34;&gt;PicoCluster&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All you need is a PicoCluster kit for a 3-node or 5-node cluster, a couple of
Raspberry Pi&amp;rsquo;s and the time to assemble all the parts together. The project can be
completed within an hour only, and makes so much fun, too - especially when you can
share this as quality time with your kids.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-pdu-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;PicoCluster had just sent us two different kits of their cool Raspberry Pi
clusters. Of course, we are eager to build these new clusters so you can get a first impression.&lt;/p&gt;

&lt;h3 id=&#34;what-s-in-the-box:098640bbbda183ea709087a458ce9550&#34;&gt;What&amp;rsquo;s in the box&lt;/h3&gt;

&lt;p&gt;3-node PicoCluster kit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;acrylic case, all parts&lt;/li&gt;
&lt;li&gt;PDU (12V input, 4x USB 5V output), including all wires&lt;/li&gt;
&lt;li&gt;wiring for 3x microUSB power&lt;/li&gt;
&lt;li&gt;case wiring for 1x HDMI&lt;/li&gt;
&lt;li&gt;case wiring for 1x 12V power plug&lt;/li&gt;
&lt;li&gt;base mounting for Pi tower, including all crews, nuts &amp;amp; bolts, spacers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-parts.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;5-node PicoCluster kit:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;acrylic case, all parts&lt;/li&gt;
&lt;li&gt;internal 8-port Ethernet switch&lt;/li&gt;
&lt;li&gt;PDU (12V input, 5x USB 5V output), including all wires&lt;/li&gt;
&lt;li&gt;wiring for 5x microUSB power&lt;/li&gt;
&lt;li&gt;wiring for network (Raspberry Pi to Ethernet switch)&lt;/li&gt;
&lt;li&gt;case wiring for 1x Ethernet&lt;/li&gt;
&lt;li&gt;case wiring for 1x HDMI&lt;/li&gt;
&lt;li&gt;case wiring for 2x USB&lt;/li&gt;
&lt;li&gt;case wiring for 1x 12V power plug&lt;/li&gt;
&lt;li&gt;base mounting for Pi tower, including all crews, nuts &amp;amp; bolts, spacers&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-parts.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Not included in the kits: (so you have to buy it separately)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi’s and microSD cards&lt;/li&gt;
&lt;li&gt;AC adapter (12V, 1.5A, barrel plug 5.5x2.1mm)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally we&amp;rsquo;ll need some common tools for the mechanical assembling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;philips screw driver&lt;/li&gt;
&lt;li&gt;7mm wrench (or a pliers)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/tools-screwdriver-wrench.jpg&#34; alt=&#34;PicoCluster toosl&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;assembling-the-3-node-picocluster:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the 3-node PicoCluster&lt;/h3&gt;

&lt;h4 id=&#34;towering-the-raspberry-pi-s:098640bbbda183ea709087a458ce9550&#34;&gt;Towering the Raspberry Pi&amp;rsquo;s&lt;/h4&gt;

&lt;p&gt;First we take the mounting plate for the Pi tower and stack all
three Raspberry Pi&amp;rsquo;s with the help of the included spacers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-pi-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wiring-all-together:098640bbbda183ea709087a458ce9550&#34;&gt;Wiring all together&lt;/h4&gt;

&lt;p&gt;Now it&amp;rsquo;s easy to mount the PDU on top of the Pi tower with 4 screws and attaching
the USB power cables to the three Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-pdu-tower2.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we mount the tower on the base plate, which makes our new cluster look even better.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-base-tower.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;From now on, it&amp;rsquo;s easy to complete the cluster installation: We connect
the 12V power cable to the PDU and front cover. We can also attach the HDMI cable
to the upper Raspberry Pi and mount the other end to the front cover, too.&lt;/p&gt;

&lt;h4 id=&#34;assembling-the-case:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the case&lt;/h4&gt;

&lt;p&gt;Finally, we mount the side and back cover and put on the top plate.
Mounting with nuts &amp;amp; bolts and the PicoCluster is ready.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Don&amp;rsquo;t forget to flash your microSD cards and insert them into the Pi&amp;rsquo;s,
because as soon as we close the cluster case, it&amp;rsquo;s a little bit harder to change
the SD cards.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-completed.jpg&#34; alt=&#34;PicoCluster 3-node&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;assembling-the-5-node-picocluster:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the 5-node PicoCluster&lt;/h3&gt;

&lt;h4 id=&#34;towering-the-raspberry-pi-s-1:098640bbbda183ea709087a458ce9550&#34;&gt;Towering the Raspberry Pi&amp;rsquo;s&lt;/h4&gt;

&lt;p&gt;With the 5-node cluster we start similar as with the 3-node. We take
the mounting plate for the Pi tower and stack all five Raspberry Pi&amp;rsquo;s with the
spacers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-pi-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;
&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-pi-tower2.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;wiring-all-together-1:098640bbbda183ea709087a458ce9550&#34;&gt;Wiring all together&lt;/h4&gt;

&lt;p&gt;Next, we mount the PDU on top of the Pi tower with 4 screws and attach
the USB power cables to the five Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-pdu-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As soon as we mount the tower on the base plate, we see that we do have a lot more
parts left.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-base-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For the 5-node cluster we have an internal dedicated 8-port switch, which we&amp;rsquo;ll
install inside the case and wire all the ethernet cables to the Pi&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-ethernet-switch.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;From now on, it&amp;rsquo;s easy to complete the cluster installation: We connect
the 12V power cable to the PDU and front cover. We can also attach the HDMI cable
to the upper Raspberry Pi and mount the other end to the front cover, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-5node-switch-tower.jpg&#34; alt=&#34;PicoCluster 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll also find two USB cables in the kit, which you can connect to one or two
different Pi&amp;rsquo;s and mount the plug to the front panel as well. Attaching HDMI and USB
plugs to the case is really optional.&lt;/p&gt;

&lt;h4 id=&#34;assembling-the-case-1:098640bbbda183ea709087a458ce9550&#34;&gt;Assembling the case&lt;/h4&gt;

&lt;p&gt;Finally, we mount the side and back cover and put on the top plate.
Mounting with nuts &amp;amp; bolts and our second PicoCluster is almost ready. As there are a
few more parts to assemble the 5-node cluster, it will take a little bit longer than
building the smaller cluster.&lt;/p&gt;

&lt;h3 id=&#34;finally-we-have-two-new-clusters:098640bbbda183ea709087a458ce9550&#34;&gt;Finally, we have two new clusters&lt;/h3&gt;

&lt;p&gt;At the end we have now built two new Raspberry Pi clusters, a 3-node and a 5-node
from PicoCluster. Both are looking really neat and everything is stowed away in
a perfect way. Only accessing the microSD cards is not optimal once after the case
is closed. You just have to remove only a few screws and dismounting the rear side
panel of the case and then you can easily access the SD card slots.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/picocluster-kits/picocluster-3node-and-5node-cluster.jpg&#34; alt=&#34;PicoCluster 3- and 5-node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Because the 5-node cluster includes an integrated 8-port Ethernet switch, we&amp;rsquo;d recommend
it to use as a standalone Pi cluster for experimenting with Docker Swarm and other
cluster related tutorials and demos. You just have to attach a 12V power source and
a single network link. This is all you need to start playing with it right away.&lt;/p&gt;

&lt;p&gt;Now, you can go ahead and install software on your new PicoCluster.
However, this isn&amp;rsquo;t within the scope of this hands-on project, so we&amp;rsquo;ll point you to one of our
latest tutorials where you learn &lt;a href=&#34;http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/&#34;&gt;how to setup a Docker Swarm cluster with Raspberry Pi&amp;rsquo;s&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;where-can-you-get-it:098640bbbda183ea709087a458ce9550&#34;&gt;Where can you get it ?&lt;/h3&gt;

&lt;p&gt;You can order your own ready-to-use and tiny data center directly at &lt;a href=&#34;http://picocluster.com&#34;&gt;PicoCluster&lt;/a&gt;
with the Raspberry Pi&amp;rsquo;s included. The hardware kits we used in this post should be available soon, too.
PicoCluster is currently optimizing a few parts like the PDU to get more power for the new Raspberry Pi 3,
so we expect the next version will get some changes and improvements compared to these
beta units.&lt;/p&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this project at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker on Raspberry Pi Workshop in Brussels</title>
      <link>http://localhost:1313/post/docker-on-arm-workshops/</link>
      <pubDate>Thu, 17 Mar 2016 00:00:00 +0100</pubDate>
      
      <guid>http://localhost:1313/post/docker-on-arm-workshops/</guid>
      <description>&lt;p&gt;A couple of weeks ago we have been invited by the fine folks over at the Docker User Group in Brussels to help conduct a workshop.
And of course this workshop was about Docker. Still it was not your ordinary Docker workshop.&lt;/p&gt;

&lt;p&gt;It was special because instead of being a workshop about Docker on big servers it was about Docker on really small ARM devices.
The very same devices that power the upcoming IoT revolution.&lt;/p&gt;

&lt;p&gt;Turns out it is really amazing what you can do with Docker on those tiny machines.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/docker_workshop.jpg&#34; alt=&#34;Raspberry Pi Workshop in Brussels&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this workshop attendees learned how to get started with Docker on their Raspberry Pi&amp;rsquo;s.
Starting with the basics they soon turned to advanced topics like building a Docker cluster.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;What is Raspberry Pi and how is it working&lt;/li&gt;
&lt;li&gt;How to flash an SD card with HypriotOS&lt;/li&gt;
&lt;li&gt;How to log in to a Raspberry Pi via SSH or serial console&lt;/li&gt;
&lt;li&gt;How to do basic stuff with Docker&lt;/li&gt;
&lt;li&gt;What is different when using Docker on ARM compared to Intel&lt;/li&gt;
&lt;li&gt;How to build a Docker Cluster with Docker Swarm&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dieter Reuter from our team gave an introductory talk and showed off some of the cool things we did at Hypriot.
About 70 people attended the workshop and worked in small groups and helped each other to learn new stuff.
Even days after the event Dieter was still raving about the cool event and the amazing, open-minded and friendly people.&lt;/p&gt;

&lt;p&gt;As you can see from the pictures it was a lot of fun to be there.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Docker &amp;amp; Raspberry Pi Workshop in Brussels&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-02.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-02.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Dieter giving a talk&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Dieter giving a talk
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-01.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-01.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-03.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-03.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-04.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-04.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-05.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-05.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/raspberry-pi-workshop/workshop-06.jpeg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;600x450&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/raspberry-pi-workshop/thumbnails/thumb_workshop-06.jpeg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;Special thanks for making the workshop possible need to go to Damien Duportal.
His workshop presentation can be found &lt;a href=&#34;http://dduportal.github.io/presentations/docker-meetup-brussels-20160210/#1&#34;&gt;here&lt;/a&gt;.
The example app that was used during the workshop was ported to ARM and can be found &lt;a href=&#34;https://github.com/jmMeessen/rpi-voting-app/commits/master&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We - at the Hypriot team - are really excited to see how more and more people start to see the potential in Docker on ARM.&lt;/p&gt;

&lt;p&gt;Last week I was approached by Bastiaan Schaap from the DevOps Oost-Nederland Meetup Group to help organize a similar workshop.
It will take place on &lt;strong&gt;June, 1st in Wageningen in the Netherlands&lt;/strong&gt;. You can read more about the agenda on the &lt;a href=&#34;http://www.meetup.com/de-DE/DevOps-OostNL/events/229287742/?eventId=229287742&#34;&gt;Meetup-Website&lt;/a&gt;.
Make sure to RSVP early as there will only be a limited number of seats available.&lt;/p&gt;

&lt;p&gt;We plan to do some more workshops in the next couple of months. So if you like to see one happen in your area - please come and talk to us.
We really have a lot of fun organizing and conducting these kind of events and can come up with a ton of different workshop topics.&lt;/p&gt;

&lt;p&gt;So in this sense - hope to see you soon in person.
Happy ARM hacking until then. :)&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Docker Sensor Fu on a Raspberry Pi</title>
      <link>http://localhost:1313/post/docker-sensor-fu-on-a-raspberry-pi/</link>
      <pubDate>Tue, 15 Mar 2016 23:02:30 +0100</pubDate>
      
      <guid>http://localhost:1313/post/docker-sensor-fu-on-a-raspberry-pi/</guid>
      <description>&lt;p&gt;For many people it comes as a surprise that one can access all the hardware of an IoT device from within a Docker container.
Interestingly enough Docker is a perfect tool for managing and distributing IoT development and production environments.&lt;/p&gt;

&lt;p&gt;To illustrate this use case we are going to create a Docker image that allows us to read the data from a temperature sensor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/docker-sensor-fu-on-a-raspberry-pi/temperature.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;
&lt;div style=&#34;text-align:right; font-size: smaller&#34;&gt;Image courtesy of &lt;a href=&#34;https://www.flickr.com/photos/tmib/3336410263/in/photolist-65PYwT-hKwdXx-6Gvfse-8sZyde-hKwe8n-bsrVBM-aTuQm-suTVL-4keeLT-9HAaQv-6owaBS-pcKw75-ktYU9-7fCvHx-aMp4hZ-9CJPmM-5kQCwW-9uhoBD-i6h8R-8eACxB-73fGHE-ecUmhW-4ayKHW-coQnPs-x2g2w-qTtWEg-6afv15-7zQM2j-coQoDf-6uLDRM-5srT3L-hpQH9p-q1QZca-9S8ygg-mHCs1e-aZ3SJT-b3ejpi-qvDRpB-mBUjjp-mJTYFr-nhZUoo-6dRUnb-9tuUnt-eMRL2K-6K6ars-dhBwB7-5Cr4jF-5rq6uU-yzubv-q7g6xP&#34;&gt;tmib_seattle&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;To follow along you gonna need:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Raspberry Pi 1, 2 or 3&lt;/li&gt;
&lt;li&gt;our HypriotOS &lt;a href=&#34;https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip&#34;&gt;SD card image&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;a DHT22 temperature sensor, which you can buy at &lt;a href=&#34;http://www.amazon.de/gp/product/B00LHJUU1M?psc=1&amp;amp;redirect=true&amp;amp;ref_=oh_aui_detailpage_o02_s00&#34;&gt;Amazon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the hardware side we need to first attach the sensor to our Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/docker-sensor-fu-on-a-raspberry-pi/temperature_sensor.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Looking at the picture of the sensor from left to right we need to attach&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the yellow cable to the 3,3V Pin of the RPi (Pin 1)&lt;/li&gt;
&lt;li&gt;the green cable (data) to one of the many GPIO; here it is GPIO2 (Pin 3)&lt;/li&gt;
&lt;li&gt;and finally the blue cable to GND (Pin 6)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The information in brackets corresponds to the pin numbers in this &lt;a href=&#34;http://raspi.tv/wp-content/uploads/2013/07/Rev2-GPIO-bold.jpg&#34;&gt;GPIO overview image&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/docker-sensor-fu-on-a-raspberry-pi/sensor_connected_to_pi.jpg&#34; alt=&#34;Docker Swarm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;After our hardware is settled we need to look at the software side of things.&lt;/p&gt;

&lt;p&gt;As foundation for our next steps we will use the &lt;a href=&#34;http://wiringpi.com/&#34;&gt;WiringPi&lt;/a&gt; project.
WiringPi is a library that allows to access the GPIO (General Purpose Input Output) connectors of the Raspberry Pi.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s put WiringPi into a Docker image, shall we?&lt;/p&gt;

&lt;p&gt;The Dockerfile for this looks like this:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Govinda-Fichtner/1d48543a6b9c2e21b7c1.js?file=Dockerfile.start&#34;&gt;&lt;/script&gt;

&lt;p&gt;Using this Dockerfile we can now build our image:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build -t hypriot/wiringpi:latest .
...
$ docker images
REPOSITORY                            TAG                 IMAGE ID            CREATED             SIZE
hypriot/wiringpi                      latest              599e98bd4c20        30 seconds ago      302.2 MB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the image has everything that we need to compile software. On top of that it also has the WiringPi libraries on board.&lt;/p&gt;

&lt;p&gt;Next we can run this image to build the software that actually reads the sensor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --device /dev/ttyAMA0:/dev/ttyAMA0 --device /dev/mem:/dev/mem --privileged -ti hypriot/wiringpi bash
root@84f66e14df05:/data#
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test if we can access the GPIO&amp;rsquo;s we can run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data# gpio readall
 +-----+-----+---------+------+---+---Pi 2---+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 |     |     |    3.3v |      |   |  1 || 2  |   |      | 5v      |     |     |
 |   2 |   8 |   SDA.1 |   IN | 1 |  3 || 4  |   |      | 5V      |     |     |
 |   3 |   9 |   SCL.1 |   IN | 1 |  5 || 6  |   |      | 0v      |     |     |
 |   4 |   7 | GPIO. 7 |   IN | 1 |  7 || 8  | 1 | ALT0 | TxD     | 15  | 14  |
 |     |     |      0v |      |   |  9 || 10 | 1 | ALT0 | RxD     | 16  | 15  |
 |  17 |   0 | GPIO. 0 |   IN | 0 | 11 || 12 | 0 | IN   | GPIO. 1 | 1   | 18  |
 |  27 |   2 | GPIO. 2 |   IN | 0 | 13 || 14 |   |      | 0v      |     |     |
 |  22 |   3 | GPIO. 3 |   IN | 0 | 15 || 16 | 0 | IN   | GPIO. 4 | 4   | 23  |
 |     |     |    3.3v |      |   | 17 || 18 | 0 | IN   | GPIO. 5 | 5   | 24  |
 |  10 |  12 |    MOSI |   IN | 0 | 19 || 20 |   |      | 0v      |     |     |
 |   9 |  13 |    MISO |   IN | 0 | 21 || 22 | 0 | IN   | GPIO. 6 | 6   | 25  |
 |  11 |  14 |    SCLK |   IN | 0 | 23 || 24 | 1 | IN   | CE0     | 10  | 8   |
 |     |     |      0v |      |   | 25 || 26 | 1 | IN   | CE1     | 11  | 7   |
 |   0 |  30 |   SDA.0 |   IN | 1 | 27 || 28 | 1 | IN   | SCL.0   | 31  | 1   |
 |   5 |  21 | GPIO.21 |   IN | 1 | 29 || 30 |   |      | 0v      |     |     |
 |   6 |  22 | GPIO.22 |   IN | 1 | 31 || 32 | 0 | IN   | GPIO.26 | 26  | 12  |
 |  13 |  23 | GPIO.23 |   IN | 0 | 33 || 34 |   |      | 0v      |     |     |
 |  19 |  24 | GPIO.24 |   IN | 0 | 35 || 36 | 0 | IN   | GPIO.27 | 27  | 16  |
 |  26 |  25 | GPIO.25 |   IN | 0 | 37 || 38 | 0 | IN   | GPIO.28 | 28  | 20  |
 |     |     |      0v |      |   | 39 || 40 | 0 | IN   | GPIO.29 | 29  | 21  |
 +-----+-----+---------+------+---+----++----+---+------+---------+-----+-----+
 | BCM | wPi |   Name  | Mode | V | Physical | V | Mode | Name    | wPi | BCM |
 +-----+-----+---------+------+---+---Pi 2---+---+------+---------+-----+-----+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far so good.&lt;/p&gt;

&lt;p&gt;Now we need to clone the source of our sensor reading software:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data# git clone https://github.com/technion/lol_dht22
root@84f66e14df05:/data# cd lol_dht22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To compile the lol_dht22 software we do the usual &lt;code&gt;./configure &amp;amp;&amp;amp; make&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data/lol_dht22# ./configure
...
root@84f66e14df05:/data/lol_dht22# make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This should produce a small executable that we can now test.&lt;/p&gt;

&lt;p&gt;If you followed the wiring instructions above closely you should now be able to read the temperature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root@84f66e14df05:/data/lol_dht22# ./loldht 8
Raspberry Pi wiringPi DHT22 reader
www.lolware.net
Humidity = 34.00 % Temperature = 22.80 *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Awesome. We just have been accessing the hardware sensor that is attached to our Pi from inside a Docker container.&lt;/p&gt;

&lt;p&gt;So why is this so exciting? Well, it basically allows us to deploy our sensor reading software easily and reliably to every device that is running a Docker Engine.
No installation hassle. No dependency hell.&lt;/p&gt;

&lt;p&gt;For that we need to extend our Dockerfile and add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUN git clone https://github.com/technion/lol_dht22
RUN cd lol_dht22 &amp;amp;&amp;amp; ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; mv ./lol_dht22 /usr/local/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The finished file looks like this:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/Govinda-Fichtner/1d48543a6b9c2e21b7c1.js?file=Dockerfile.final&#34;&gt;&lt;/script&gt;

&lt;p&gt;After rebuilding the image with this updated Dockerfile we can now run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker run --device /dev/ttyAMA0:/dev/ttyAMA0 --device /dev/mem:/dev/mem --privileged -ti hypriot/wiringpi /loldht 8
Raspberry Pi wiringPi DHT22 reader
www.lolware.net
Data not good, skip
Humidity = 35.00 % Temperature = 22.00 *C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it just works&amp;trade;.&lt;/p&gt;

&lt;p&gt;The finished image can be found at the &lt;a href=&#34;https://hub.docker.com/r/hypriot/wiringpi/&#34;&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. As always, use the comments below to give us feedback and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile__&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to build a traffic light</title>
      <link>http://localhost:1313/post/traffic-light/</link>
      <pubDate>Sun, 13 Mar 2016 17:31:10 +0100</pubDate>
      
      <guid>http://localhost:1313/post/traffic-light/</guid>
      <description>

&lt;p&gt;My seven year old asked me how does a traffic light work. Before explaining too much we put some LEDs and wires together and did a hands-on tutorial. Finally we had a pedestrian crossing with a push button controlled by an app - of course - running dockerized on a Raspberry Pi 3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/traffic-light/traffic-light.png&#34; alt=&#34;Traffic light wiring&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-hardware:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;The hardware&lt;/h2&gt;

&lt;p&gt;First we have to build the curcuit. To follow this tutorial you need these parts&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Raspberry Pi 3, but any other is also good for this tutorial&lt;/li&gt;
&lt;li&gt;Adafruit T-Cobbler Plus&lt;/li&gt;
&lt;li&gt;Breadboard&lt;/li&gt;
&lt;li&gt;2x Red, 1x yellow and 2x green LEDs&lt;/li&gt;
&lt;li&gt;5x 220Ω resistors&lt;/li&gt;
&lt;li&gt;1x 1kΩ resistor&lt;/li&gt;
&lt;li&gt;1x 10kΩ resistor&lt;/li&gt;
&lt;li&gt;1x push button&lt;/li&gt;
&lt;li&gt;1x USB power for the Raspberry Pi&lt;/li&gt;
&lt;li&gt;cables&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;the-software:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;The software&lt;/h2&gt;

&lt;p&gt;The application is written in Python and it is based on the blog post &lt;a href=&#34;http://www.bobrathbone.com/pi_traffic_led.htm&#34;&gt;Raspberry PI Traffic Lights&lt;/a&gt; by Bob Rathbone. I have added some more LEDs and changed it to our local traffic light scheme. You can find the full source code &lt;a href=&#34;https://github.com/StefanScherer/docker-rpi-traffic-light&#34;&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;defining-the-gpio-pins:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Defining the GPIO pins&lt;/h3&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=16:30&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;initializing-the-gpio-ports:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Initializing the GPIO ports&lt;/h3&gt;

&lt;p&gt;At the beginning of the app we initialize the GPIO ports and turn off all LEDs. They may turned on from aborting a previous run.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=31:48&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;main-loop:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Main loop&lt;/h3&gt;

&lt;p&gt;The main loop begins with green lights for the cars. In this state the button for the pedestrian crossing is checked.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=49:64&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h3 id=&#34;pedestrian-crossing:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Pedestrian crossing&lt;/h3&gt;

&lt;p&gt;After the button has been pressed the next code block just changes the LEDs for the cars to red, green for pedestrians and back again.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/pedestrian-crossing.py?slice=64:&amp;footer=minimal&#34;&gt;&lt;/script&gt;

&lt;p&gt;That completes the whole app. I could explain how a traffic light works and my daughter could play with it for a while. This could be the whole story, but as I&amp;rsquo;ve deployed my app with Docker there is another story behind the story.&lt;/p&gt;

&lt;h1 id=&#34;dockerize-all-the-things:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Dockerize all the things&lt;/h1&gt;

&lt;p&gt;I want to save my work and make it reproducible for me and others. So beside putting the source code into a GitHub repo I also dockerized the application development and deployment. With the help of Docker and the Docker tools it is very easy to develop from eg. a MacBook.&lt;/p&gt;

&lt;p&gt;Even after months and other projects it is easy to spin up that application again as there is a standardized way. There also is no need to backup the SD image and write down what you had to install on your Raspberry Pi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/traffic-light/mac_rpi_development.png&#34; alt=&#34;Developing for RPi from a Mac&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As shown in the diagram your Notebook should have the following tools installed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;flash tool&lt;/a&gt;&lt;/strong&gt; to flash the SD card image with HypriotOS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com/machine/overview/&#34;&gt;Docker Machine&lt;/a&gt;&lt;/strong&gt; to build a secured connection to the Raspberry Pi Docker Engine&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com/compose/overview/&#34;&gt;Docker Compose&lt;/a&gt;&lt;/strong&gt; to easily start dockerized apps with a single command&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&#34;https://docs.docker.com&#34;&gt;Docker Client&lt;/a&gt;&lt;/strong&gt; to run other Docker commands&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I don&amp;rsquo;t get into the details on how to connect your Notebook with the Docker Engine on the Raspberry Pi. This is part of a &lt;a href=&#34;http://blog.hypriot.com/post/how-to-setup-rpi-docker-swarm/&#34;&gt;previous blog post&lt;/a&gt; how to use docker-machine for that.&lt;/p&gt;

&lt;h2 id=&#34;dockerfile:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Dockerfile&lt;/h2&gt;

&lt;p&gt;To build the Docker image we need a Dockerfile. We use a Python base image and install the needed tools and dependencies. Then we add the application source code and define the command to execute.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/Dockerfile?footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;docker-compose-yml:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;docker-compose.yml&lt;/h2&gt;

&lt;p&gt;Docker Compose can be used to simplify running the container. With the docker-compose.yml we can document all the parameters needed to start the container. The file is versioned in Git so we do not forget how to run this container.&lt;/p&gt;

&lt;script src=&#34;https://gist-it.appspot.com/github/StefanScherer/docker-rpi-traffic-light/raw/master/docker-compose.yml?footer=minimal&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;developing-the-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Developing the app&lt;/h2&gt;

&lt;p&gt;When you develop the app or want to modify the source code the Docker image has to be rebuilt with the new code. To do this just run this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;running-the-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Running the app&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to stop the app again, just press &lt;code&gt;CTRL+C&lt;/code&gt;. You may have to press it twice to kill the app.&lt;/p&gt;

&lt;h2 id=&#34;running-permanently:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Running permanently&lt;/h2&gt;

&lt;p&gt;You can run the application automatically by adding &lt;code&gt;-d&lt;/code&gt;. The docker-compose.yml also sets the restart policy to always, so the container is starting right after booting the Raspberry Pi. This is very useful for such hardware projects which should start automatically after turning on your Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to stop the app again, just use this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose kill
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sharing-the-dockerized-app:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Sharing the dockerized app&lt;/h2&gt;

&lt;p&gt;The advantage of using Docker is to easily share the dockerized app with others. As the developer of an app you just push the Docker image with to the Docker Hub. Others can pull this Docker image from there and run it without to know which tools and dependencies to install.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/traffic-light/mac_rpi_docker_push.png&#34; alt=&#34;Developing for RPi from a Mac&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;pushing-the-docker-image:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Pushing the Docker image&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;docker images
docker tag dockerrpitrafficlight_trafficlight stefanscherer/rpi-traffic-light
docker push stefanscherer/rpi-traffic-light
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Docker image is send sent to the Docker Hub. My example is available as image &lt;a href=&#34;https://hub.docker.com/r/stefanscherer/rpi-traffic-light/&#34;&gt;stefanscherer/rpi-traffic-light&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;sharing-with-others:36e2dfd970af1a18eb3decac8ff94950&#34;&gt;Sharing with Others&lt;/h2&gt;

&lt;p&gt;If someone else wants to build the traffic light and run your application, she has to use this little modified docker-compose.yml to pull the published Docker image instead of building it herself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;version: &#39;2&#39;
services:
  trafficlight:
    image: stefanscherer/rpi-traffic-light
    devices:
      - &amp;quot;/dev/mem:/dev/mem&amp;quot;
    cap_add:
      - SYS_RAWIO
    restart: always
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then run the application with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or use the docker command with all the parameters&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --rm --cap-add SYS_RAWIO --device /dev/mem stefanscherer/rpi-traffic-light
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This command pulls the Docker image from the Docker hub if it isn&amp;rsquo;t available locally on the Raspberry Pi. After that it runs a Docker container with the application.&lt;/p&gt;

&lt;p&gt;In this way any app can be published in the same way, regardless the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;
&lt;div class=&#34;title&#34;&gt;Building a traffic light with Raspberry Pi 3&lt;/div&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/hardwired.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_hardwired.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;First hardwired setup. Pull the wires to switch lights.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    First hardwired setup. Pull the wires to switch lights.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/cars-green.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_cars-green.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Cars have green, pedestrians have to wait.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Cars have green, pedestrians have to wait.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/push-button.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_push-button.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Push the button!&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Push the button!
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/walk.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_walk.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Cars have to stop, pedestrian may cross the road.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Cars have to stop, pedestrian may cross the road.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/drive.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_drive.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Safely crossed the street. Cars driving again.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Safely crossed the street. Cars driving again.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/raspberry-pi3-edimax.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_raspberry-pi3-edimax.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Raspberry Pi 3 running traffic light app. Edimax as workaround, soon onboard WiFi support.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Raspberry Pi 3 running traffic light app. Edimax as workaround, soon onboard WiFi support.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/traffic-light/development.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1600x1200&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/traffic-light/thumbnails/thumb_development.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Build, Ship and Run from a Mac&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Build, Ship and Run from a Mac
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Hypriot&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to setup a Docker Swarm cluster with Raspberry Pi&#39;s</title>
      <link>http://localhost:1313/post/how-to-setup-rpi-docker-swarm/</link>
      <pubDate>Tue, 08 Mar 2016 17:27:58 +0100</pubDate>
      
      <guid>http://localhost:1313/post/how-to-setup-rpi-docker-swarm/</guid>
      <description>

&lt;p&gt;This week is dedicated to &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-join-your-first-swarm/&#34;&gt;Docker #SwarmWeek&lt;/a&gt;. In this tutorial we show you how easy it is to setup a Docker Swarm with HypriotOS and the standard &lt;code&gt;docker-machine&lt;/code&gt; binary.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/how-to-setup-rpi-docker-swarm/docker-swarm-logo.png&#34; alt=&#34;Docker Swarm&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We want to setup a cluster with &lt;strong&gt;eight Raspberry Pi 3&lt;/strong&gt;, grouped into two tiny datacenters with four Pi&amp;rsquo;s each.&lt;/p&gt;

&lt;h2 id=&#34;prepare-your-notebook:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Prepare your notebook&lt;/h2&gt;

&lt;p&gt;To control the Docker Swarm from our notebook, we have to install both &lt;code&gt;docker&lt;/code&gt; and &lt;code&gt;docker-machine&lt;/code&gt; binaries. If you are on a Mac, you can use &lt;code&gt;brew&lt;/code&gt; to install them.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;brew install docker
brew install docker-machine
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flash-all-your-sd-cards:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Flash all your SD cards&lt;/h2&gt;

&lt;p&gt;Now we can easily flash the latest HypriotOS image to the eight SD cards with our &lt;a href=&#34;https://github.com/hypriot/flash#installation&#34;&gt;flash tool&lt;/a&gt; and assign different node names.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;flash --hostname swarm-dc1-pi01 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
flash --hostname swarm-dc1-pi02 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
...
flash --hostname swarm-dc2-pi04 https://downloads.hypriot.com/hypriot-rpi-20160306-192317.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, insert the SD cards and boot all the Raspberry Pi&amp;rsquo;s.&lt;/p&gt;

&lt;h2 id=&#34;prepare-your-pi-s-for-docker-machine:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Prepare your Pi&amp;rsquo;s for docker-machine&lt;/h2&gt;

&lt;p&gt;We want to create the Docker Swarm with the standard &lt;code&gt;docker-machine&lt;/code&gt; binary. To make this work we need to prepare the Raspberry Pi&amp;rsquo;s a little bit. The next steps are adding your SSH public key to all of your Pi&amp;rsquo;s as well as fixing the ID in &lt;code&gt;/etc/os-release&lt;/code&gt; to &lt;code&gt;debian&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getip() { (traceroute $1 2&amp;gt;&amp;amp;1 | head -n 1 | cut -d\( -f 2 | cut -d\) -f 1) }

IP_ADDRESS=$(getip swarm-dc1-pi01.local)

ssh-keygen -R $IP_ADDRESS
ssh-copy-id -oStrictHostKeyChecking=no -oCheckHostIP=no root@$IP_ADDRESS

ssh root@$IP_ADDRESS sed -i \&#39;s/ID=raspbian/ID=debian/g\&#39; /etc/os-release
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Repeat this for all the eight Raspberry Pi&amp;rsquo;s. You will prompted for the root password which is &lt;code&gt;hypriot&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;create-swarm-token:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Create Swarm Token&lt;/h2&gt;

&lt;p&gt;A Docker Swarm cluster uses a unique Cluster ID to enable all swarm agents find each other. We need such a Cluster ID to build our Docker Swarm. This can be done in your shell with this command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;export TOKEN=$(for i in $(seq 1 32); do echo -n $(echo &amp;quot;obase=16; $(($RANDOM % 16))&amp;quot; | bc); done; echo)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;create-the-swarm-with-docker-machine:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Create the swarm with docker-machine&lt;/h2&gt;

&lt;p&gt;We now create the Swarm Master on the first Raspberry Pi.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-machine create -d generic \
  --engine-storage-driver=overlay --swarm --swarm-master \
  --swarm-image hypriot/rpi-swarm:latest \
  --swarm-discovery=&amp;quot;token://$TOKEN&amp;quot; \
  --generic-ip-address=$(getip swarm-dc1-pi01.local) \
  swarm-dc1-pi01
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For all the seven remaining Raspberry Pi&amp;rsquo;s we create Swarm Agents that join the Swarm cluster.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker-machine create -d generic \
  --engine-storage-driver=overlay --swarm \
  --swarm-image hypriot/rpi-swarm:latest \
  --swarm-discovery=&amp;quot;token://$TOKEN&amp;quot; \
  --generic-ip-address=$(getip swarm-dc1-pi02.local) \
  swarm-dc1-pi02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a while the whole Docker Swarm cluster with the two datacenters is up and running. We now have a cluster with &lt;strong&gt;32 CPU&amp;rsquo;s&lt;/strong&gt; and &lt;strong&gt;8 GByte RAM&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&#34;control-your-swarm:7086adb18de3c46a0c9331e9b3dc5f01&#34;&gt;Control your Swarm&lt;/h2&gt;

&lt;p&gt;To connect to your Docker Swarm use the following command to set the environment variables for the Docker Client.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval $(docker-machine env --swarm swarm-dc1-pi01)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/how-to-setup-rpi-docker-swarm/dc1-pi3.jpg&#34; alt=&#34;Datacenter 1&#34; /&gt;
&lt;img src=&#34;http://localhost:1313/images/how-to-setup-rpi-docker-swarm/dc2-pi3.jpg&#34; alt=&#34;Datacenter 2&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker info
Containers: 10
 Running: 9
 Paused: 0
 Stopped: 1
Images: 8
Server Version: swarm/1.1.3
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 8
 swarm-dc1-pi01: 192.168.1.207:2376
  └ Status: Healthy
  └ Containers: 3
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:47:03Z
 swarm-dc1-pi02: 192.168.1.209:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:56Z
 swarm-dc1-pi03: 192.168.1.206:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:22Z
 swarm-dc1-pi04: 192.168.1.208:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:51Z
 swarm-dc2-pi01: 192.168.1.204:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:35Z
 swarm-dc2-pi02: 192.168.1.205:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:49Z
 swarm-dc2-pi03: 192.168.1.210:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:40Z
 swarm-dc2-pi04: 192.168.1.211:2376
  └ Status: Healthy
  └ Containers: 1
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.17-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), provider=generic, storagedriver=overlay
  └ Error: (none)
  └ UpdatedAt: 2016-03-08T17:46:37Z
Plugins:
 Volume:
 Network:
Kernel Version: 4.1.17-hypriotos-v7+
Operating System: linux
Architecture: arm
CPUs: 32
Total Memory: 7.592 GiB
Name: d90d49c65205
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/how-to-setup-rpi-docker-swarm/five-pi3.jpg&#34; alt=&#34;five pi3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For more information about Docker Swarm you can follow the &lt;a href=&#34;https://blog.docker.com/2016/03/swarmweek-container-orchestration-docker-swarm/&#34;&gt;#SwarmWeek: Introduction to container orchestration with Docker Swarm&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/quintus23m&#34;&gt;@Quintus23M&lt;/a&gt; &amp;amp; Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HypriotOS 0.7.0 Berry - the Raspberry Pi Birthday release</title>
      <link>http://localhost:1313/post/new-hypriotos-berry-with-rpi3-support/</link>
      <pubDate>Mon, 07 Mar 2016 09:03:23 +0100</pubDate>
      
      <guid>http://localhost:1313/post/new-hypriotos-berry-with-rpi3-support/</guid>
      <description>&lt;p&gt;We&amp;rsquo;ve just prepared a new beta release of HypriotOS 0.7.0 Berry which is based upon an updated 0.6.1 Hector. Feel free to check it out: &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;http://blog.hypriot.com/downloads/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/hypriotos-berry-rpi3/IMG_0763.jpeg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Features:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;basic support for Raspberry Pi 3 B (internal WiFi/BT is currently not supported)&lt;/li&gt;
&lt;li&gt;Linux kernel 4.1.17&lt;/li&gt;
&lt;li&gt;Docker Engine 1.10.2&lt;/li&gt;
&lt;li&gt;Docker Compose 1.6.2&lt;/li&gt;
&lt;li&gt;Swarm 1.1.3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This SD image still works on all available Raspberry Pi models (really!)&lt;/p&gt;

&lt;p&gt;We included all the latest Docker tools for you and especially the new Docker Swarm 1.1.3. Together with the brand-new powerful Raspberry Pi 3 B it makes to much fun to run Docker containers.&lt;/p&gt;

&lt;p&gt;Don’t forget, this week is Docker &lt;a href=&#34;https://twitter.com/hashtag/SwarmWeek?src=hash&#34;&gt;#SwarmWeek&lt;/a&gt;. Head over to &lt;a href=&#34;https://blog.docker.com/2016/02/swarmweek-is-coming/&#34;&gt;https://blog.docker.com/2016/02/swarmweek-is-coming/&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/hypriotos-berry-rpi3/IMG_0766.jpeg&#34; alt=&#34;Raspberry Pi 3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And with the help of Docker Swarm it’s just awesome to control a fleet of Raspberry Pi’s running your awesome distributed applications.&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/quintus23m&#34;&gt;@Quintus23M&lt;/a&gt; &amp;amp; Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Run Docker on a Raspberry Pi 3 with onboard WiFi</title>
      <link>http://localhost:1313/post/run-docker-rpi3-with-wifi/</link>
      <pubDate>Sat, 05 Mar 2016 16:04:12 +0100</pubDate>
      
      <guid>http://localhost:1313/post/run-docker-rpi3-with-wifi/</guid>
      <description>

&lt;p&gt;Today morning we finally got our Raspberry Pi 3&amp;rsquo;s from ThePiHut. They have been overwhelmed by the number of orders.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/rpi3-onboard-wifi/thepihut-delivery.jpg&#34; alt=&#34;ThePiHut delivery&#34; /&gt;&lt;/p&gt;

&lt;p&gt;While waiting for the delivery we already heard from our community that the current HypriotOS SD image does not boot.&lt;/p&gt;

&lt;p&gt;But with some little tweaks the first people have started running Docker containers with HypriotOS. We will update our image builder soon and publish a new HypriotOS image for an easy out-of-the-box experience.&lt;/p&gt;

&lt;p&gt;In the meantime for all the impatient out there I&amp;rsquo;ll give you a short intro how to run the latest Docker Engine on the standard Raspbian SD image.&lt;/p&gt;

&lt;h2 id=&#34;download-raspbian-lite:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Download Raspbian LITE&lt;/h2&gt;

&lt;p&gt;Just download and flash the Raspbian LITE image from &lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;https://www.raspberrypi.org/downloads/raspbian/&lt;/a&gt; or use our &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;&lt;code&gt;flash&lt;/code&gt; script&lt;/a&gt; with this command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;flash https://downloads.raspberrypi.org/raspbian_lite_latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now boot your Raspberry Pi 3 and log into it with user &lt;code&gt;pi&lt;/code&gt; and the password &lt;code&gt;raspberry&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@raspberrypi.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard Raspbian image does not resize the SD filesystem automatically.&lt;/p&gt;

&lt;h2 id=&#34;add-the-overlay-kernel-module:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Add the overlay kernel module&lt;/h2&gt;

&lt;p&gt;Before we resize and reboot the Pi we also customize a little bit. The overlay kernel module must be loaded automatically while booting, so we just add it with the next command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &amp;quot;overlay&amp;quot; | sudo tee -a /etc/modules
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;customize-wifi:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Customize WiFi&lt;/h2&gt;

&lt;p&gt;If you want to run your Docker with the onboard WiFi, just add your SSID and pre-shared key with the next command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;echo &#39;network={
  ssid=&amp;quot;your-ssid&amp;quot;
  psk=&amp;quot;your-psk&amp;quot;
}&#39; | sudo tee -a /etc/wpa_supplicant/wpa_supplicant.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;resize-filesystem:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Resize filesystem&lt;/h2&gt;

&lt;p&gt;Now we have to resize the filesystem to install Docker and have space for Docker images and containers. Start &lt;code&gt;raspi-config&lt;/code&gt; and follow the steps to resize your filesystem.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo raspi-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that let raspi-config reboot your Raspberry Pi.&lt;/p&gt;

&lt;h2 id=&#34;cut-the-wires:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Cut the wires&lt;/h2&gt;

&lt;p&gt;If you have added your WiFi settings, remove your network cable while rebooting. From now on you can connect to your Raspberry Pi 3 over the air.&lt;/p&gt;

&lt;h2 id=&#34;install-docker:41cd8e8b967fec6fd9b7dfd6fb7de44e&#34;&gt;Install Docker&lt;/h2&gt;

&lt;p&gt;After rebooting, eventually unplugging the network cable we have to install Docker. The Raspbian Jessie distribution also has a Docker package, but it is only Version 1.3.3. So we install the Hypriot&amp;rsquo;s Docker 1.10.2 instead.&lt;/p&gt;

&lt;p&gt;Just log into your Raspberry Pi 3 again and install Docker with these commands.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh pi@raspberrypi.local
sudo apt-get install -y apt-transport-https
wget -q https://packagecloud.io/gpg.key -O - | sudo apt-key add -
echo &#39;deb https://packagecloud.io/Hypriot/Schatzkiste/debian/ wheezy main&#39; | sudo tee /etc/apt/sources.list.d/hypriot.list
sudo apt-get update
sudo apt-get install -y docker-hypriot
sudo systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you have a good setup until the next HypriotOS release is coming.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/rpi3-onboard-wifi/rpi3-raspbian-lite-docker-version.png&#34; alt=&#34;docker version&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And with the onboard WiFi it is now very easy to build some mobile Docker IoT projects.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/rpi3-onboard-wifi/rpi3-over-the-air.jpg&#34; alt=&#34;docker over the air&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.&lt;/p&gt;

&lt;p&gt;Stefan &lt;a href=&#34;https://twitter.com/stefscherer&#34;&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Pine A64 is about to become the cheapest ARM 64-bit platform to run Docker</title>
      <link>http://localhost:1313/post/the-pine-a64-is-about-to-become=the-cheapest-ARM-64-bit-platform-to-run-Docker/</link>
      <pubDate>Mon, 25 Jan 2016 23:55:00 +0100</pubDate>
      
      <guid>http://localhost:1313/post/the-pine-a64-is-about-to-become=the-cheapest-ARM-64-bit-platform-to-run-Docker/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/close_up_front_pine_06.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Last Saturday one of the more promising &lt;a href=&#34;https://www.kickstarter.com/projects/pine64/pine-a64-first-15-64-bit-single-board-super-comput&#34;&gt;Kickstarter campaigns&lt;/a&gt;
that piqued our curiosity ended after 44 days and was able to raise &lt;strong&gt;1.7 million dollars&lt;/strong&gt;.
It was a campaign to fund the cheapest 64-bit ARM board that can currently be bought for money.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Pine A64 sells for 15 bucks&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So why is that noteworthy when there are boards like the Pi Zero around that sell for $5?&lt;/p&gt;

&lt;p&gt;It very much is, when you put that price into perspective. The cheapest 64-bit ARM board we knew before the Pine was
the &lt;a href=&#34;http://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/&#34;&gt;NVIDIA ShieldTV&lt;/a&gt;, which sells for about $200.
Next comes the much more expensive &lt;a href=&#34;http://www.slashgear.com/amd-starts-shipping-seattle-arm-server-chips-14423259/&#34;&gt;AMD Opteron A1100 series&lt;/a&gt; where an individual chip alone starts with a price tag of $150.&lt;/p&gt;

&lt;p&gt;All in all that means that the Pine A64 is the most affordable way to lay your hands on real 64-bit ARM hardware - and that by a long shot!
So what can you actually do with such a device?&lt;/p&gt;

&lt;p&gt;Lots of things of course, but &lt;strong&gt;for us at Hypriot, the first thing we think about anything is: Can we run Docker on it?&lt;/strong&gt;
And the short answer is: probably yes. But more about that later.&lt;/p&gt;

&lt;h2 id=&#34;the-hardware:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The Hardware&lt;/h2&gt;

&lt;p&gt;Before we deep dive into the nitty gritty details, let&amp;rsquo;s first take a step back and see what the Pine A64 has to offer hardware-wise.&lt;/p&gt;

&lt;p&gt;The Pine A64 does have&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a &lt;strong&gt;quad-core Cortex A53 CPU&lt;/strong&gt; with 1,2 Ghz&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;64-bit&lt;/strong&gt; processor architecture&lt;/li&gt;
&lt;li&gt;up to &lt;strong&gt;2 GB of DDR3 memory&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;a version with &lt;strong&gt;Gigabit Ethernet&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;the ability to play 4K video&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;What excites us the most here, is the 64-bit architecture combined with 2 GB of memory and Gigabit Ethernet.&lt;/p&gt;

&lt;p&gt;Those specs set the Pine A64 distinctly apart from the Raspberry Pi 2, which much to our regret only provides 100 Megabit Ethernet.
Just be aware that you&amp;rsquo;ll get these specs only with the high-end version of the Pine. It is called the A64+ and costs a bit more with $19 (1 GB version) or $29 (2 GB version).
&lt;strong&gt;Even at $19 for the 1 GB version that&amp;rsquo;s nearly half of the price of a Raspberry Pi 2.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If it turns out that the build quality and support of the board is on par with that of the Raspberry Pi that could indeed considered an impressive accomplishment.&lt;/p&gt;

&lt;p&gt;We were lucky enough to secure an early developer version of the device, which arrived a couple of days ago.
Seeing is believing and as such we prepared a couple of photos that we made from our own Pine A64+ board with 1 GB.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;





&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_front_pine_06.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_front_pine_06.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up Pine 64 FRONT&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up Pine 64 FRONT
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_back_pine_05.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_back_pine_05.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up Pine 64 BACK&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up Pine 64 BACK
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_pine_01.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_01.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 01&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 01
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Docker Inc.&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_pine_02.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_02.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 02&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 02
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_pine_03.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_03.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 03&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 03
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/close_up_pine_04.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_close_up_pine_04.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Close up 04&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Close up 04
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/pine-a64-gallery/comparison_to_other_boards.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1000x664&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/pine-a64-gallery/thumbnails/thumb_comparison_to_other_boards.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;The Pine A64 compared to a Raspberry Pi 2 and an ODroid C1&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    The Pine A64 compared to a Raspberry Pi 2 and an ODroid C1
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;h2 id=&#34;the-software:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The Software&lt;/h2&gt;

&lt;p&gt;One of the current limitations of the Pine A64 is that it only runs with Android.
The Pine makers assured us that Linux support will come, too. Still for us it is a tad annoying that Android is first instead of Linux.&lt;/p&gt;

&lt;p&gt;Impatient as we are, once we got the device, we immediately started out to rectify this by getting HypriotOS to run on it.
Relatively soon it became obvious that this would not be an easy task.&lt;/p&gt;

&lt;p&gt;Why? Well, it seems that the relationship between &lt;a href=&#34;http://www.allwinnertech.com/index.html&#34;&gt;Allwinner Technology&lt;/a&gt; and the Open-Source community has not always been the best in the past.
That basically meant that the existing &lt;a href=&#34;http://linux-sunxi.org/&#34;&gt;friendly and supportive Open-Source community&lt;/a&gt; for the Allwinner related SoC&amp;rsquo;s often had to work
with limited information and support when they tried to come up with proper Linux support for Allwinner based devices.
Still despite that some members of the Linux Sunxi Community are already busy working with the Pine A64.&lt;/p&gt;

&lt;h2 id=&#34;a-long-journey-down-the-rabbit-hole-begins-with-the-first-step:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;A long journey (down the rabbit hole) begins with the first step&lt;/h2&gt;

&lt;p&gt;The rest of this blog post describes our preliminary journey to create Linux &amp;amp; Docker bliss for the Pine A64.
And consider yourself sufficiently warned - this journey is not for the faint of heart&amp;hellip; :)&lt;/p&gt;

&lt;h3 id=&#34;down-the-rabbit-hole-output-foo-with-the-uart0-console:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Down the rabbit hole: Output foo with the UART0 console&lt;/h3&gt;

&lt;p&gt;So let&amp;rsquo;s get our hands on this new beauty. First thing you should know is how you can power the Pine A64 board.
It has a standard microUSB port, which you can use with a power adapter of 5V/2A. That&amp;rsquo;s the same you might use for a Raspberry Pi.&lt;/p&gt;

&lt;p&gt;For our first low-level steps with the board we prefer to connect to the UART0 console via an UART-to-USB connector cable.
We recommend to use one such as the &lt;a href=&#34;https://www.adafruit.com/product/954&#34;&gt;USB to TTL Serial Cable&lt;/a&gt; from Adafruit.
Adafruit also has a &lt;a href=&#34;https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable&#34;&gt;great tutorial&lt;/a&gt; on how to install the drivers for such a cable on different operating systems.&lt;/p&gt;

&lt;p&gt;For connecting via UART0 to the Pine there are basically two ways. Either via the pins of the &lt;code&gt;Euler bus&lt;/code&gt; or via the &lt;code&gt;EXT&lt;/code&gt; connectors.
The location of each can be seen on the following images. Consult the &lt;a href=&#34;http://linux-sunxi.org/Pine64#Serial_port_.2F_UART&#34;&gt;Linux-sunxi Wiki: Serial port / UART&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;Serial Console with Euler Bus:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/serial_euler.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Serial Console with Ext connector:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/serial_ext.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;To actually work with the UART0 console you have to connect the UART-to-USB cable to your Linux or Mac computer and start your preferred terminal program.&lt;/p&gt;

&lt;p&gt;Here is the command for Mac OS X:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo screen /dev/cu.usbserial 115200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Don&amp;rsquo;t be surprised that there is absolutely no sign of booting on your console screen when you connect the UART-to-USB cable to the Pine.
The only thing you will see is that the power LED on the board has turned green.&lt;/p&gt;

&lt;p&gt;This is due to the fact that the A64 SOC is reading its initial bootloader from the microSD card into memory and starts it.
Among other things this initializes the UART0 port and prints out the first boot messages.&lt;/p&gt;

&lt;p&gt;There might be two reasons if your Pine stays silent: either there is no SD card present or there is no working bootloader program found on the SD card.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s make sure that we have both.&lt;/p&gt;

&lt;p&gt;Grab a working SD card and flash an appropriate image on it.
Thanks to Andre Przywara there already is &lt;a href=&#34;https://github.com/apritzel/pine64&#34;&gt;a first experimental Linux image&lt;/a&gt; that we can use.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# replace sdx with the name of your SD card device file

$ xzcat pine64_linux-20160121.img.xz | dd of=/dev/sdx bs=1M
$ sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This SD card image is a hybrid that combines components from the original Pine 64 Android image with a recent Linux 4.4.0-rc8 kernel and initrd.
All this is more or less just cobbled together to get a first prototypical SD card image with Linux running.&lt;/p&gt;

&lt;p&gt;As this image does not include a full root file system one of the first ideas that came to our mind was to include our HypriotOS root filesystem for ARM64.
Alright, lets see if this really works.&lt;/p&gt;

&lt;p&gt;Inserting the SD card into the Pine A64 and booting produced the expected boot messages.
After some seconds the following boot Linux prompt was visible:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;BusyBox v1.22.1 (Debian 1:1.22.0-9+deb8u1) built-in shell (ash)
Enter &#39;help&#39; for a list of built-in commands.

/ #
/ #
/ #
/ # uname -a
Linux (none) 4.4.0-rc8 #20 SMP PREEMPT Mon Jan 18 01:05:25 GMT 2016 aarch64 GNU/Linux
/ # df -h
Filesystem                Size      Used Available Use% Mounted on
none                     78.5M     72.0K     78.4M   0% /run
devtmpfs                381.8M         0    381.8M   0% /dev
/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, that was the first step, but now we would like to see, if it&amp;rsquo;s really possible to boot into a HypriotOS root filesystem.
So let&amp;rsquo;s reboot the Pine. As soon as the U-Boot messages appear, hit a random key to stop the automatic boot process.
This drops us into an interactive U-Boot prompt.&lt;/p&gt;

&lt;p&gt;Next we just have to follow Andre&amp;rsquo;s documentation and tell U-Boot to boot into the root filesystem on &lt;code&gt;/dev/sda10&lt;/code&gt;, which contains our &lt;a href=&#34;https://github.com/hypriot/os-rootfs/releases/tag/v0.6.0&#34;&gt;generic HypriotOS for ARM64&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sunxi# run load_env
sunxi# run load_dtb
sunxi# run set_cmdline
sunxi# setenv kernel_part mainline
sunxi# run load_kernel
sunxi# run boot_kernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bingo! It works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/hypriotos_pine64.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here are a few snippets of the boot log from the UART0 console.
We have stored the complete boot log for you as a &lt;a href=&#34;https://gist.github.com/DieterReuter/93a5d10dae6a62911b71&#34;&gt;GitHub gist&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HELLO! BOOT0 is starting!
boot0 commit : 045061a8bb2580cb3fa02e301f52a015040c158f

boot0 version : 4.0.0
set pll start
set pll end
...
NOTICE:  BL3-1: v1.0(debug):045061a
NOTICE:  BL3-1: Built : 14:30:28, Dec  3 2015
NOTICE:  BL3-1 commit: 045061a8bb2580cb3fa02e301f52a015040c158f

INFO:    BL3-1: Initializing runtime services
INFO:    BL3-1: Preparing for EL3 exit to normal world
INFO:    BL3-1: Next image address = 0x4a000000
INFO:    BL3-1: Next image spsr = 0x1d3


U-Boot 2014.07 (Dec 03 2015 - 14:30:33) Allwinner Technology
...
Starting kernel ...

INFO:    BL3-1: Next image address = 0x41080000
INFO:    BL3-1: Next image spsr = 0x3c5
Booting Linux on physical CPU 0x0
Initializing cgroup subsys cpu
Linux version 4.4.0-rc8 (aprzywara@slackpad) (gcc version 4.9.3 (GCC) ) #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016
Boot CPU: AArch64 Processor [410fd034]
...
Welcome to Debian GNU/Linux 8 (jessie)!
...
[  OK  ] Reached target Multi-User System.
[  OK  ] Reached target Graphical Interface.

Debian GNU/Linux 8 black-pearl ttyS0

black-pearl login: pirate
Password:
Linux black-pearl 4.4.0-rc8 #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016 aarch64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
HypriotOS/arm64: pirate@black-pearl in ~
$ uname -a
Linux black-pearl 4.4.0-rc8 #21 SMP PREEMPT Wed Jan 20 22:43:20 GMT 2016 aarch64 GNU/Linux
$ cat /etc/os-release
PRETTY_NAME=&amp;quot;Debian GNU/Linux 8 (jessie)&amp;quot;
NAME=&amp;quot;Debian GNU/Linux&amp;quot;
VERSION_ID=&amp;quot;8&amp;quot;
VERSION=&amp;quot;8 (jessie)&amp;quot;
ID=debian
HOME_URL=&amp;quot;http://www.debian.org/&amp;quot;
SUPPORT_URL=&amp;quot;http://www.debian.org/support/&amp;quot;
BUG_REPORT_URL=&amp;quot;https://bugs.debian.org/&amp;quot;
HYPRIOT_OS=&amp;quot;HypriotOS/arm64&amp;quot;
HYPRIOT_TAG=&amp;quot;dirty&amp;quot;
HypriotOS/arm64: root@black-pearl in ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Success!&lt;/strong&gt; The first boot of HypriotOS/arm64 on a Pine A64 board.&lt;/p&gt;

&lt;h3 id=&#34;even-deeper-into-the-rabbit-hole-using-the-fel-mode-to-communicate-with-the-the-pine-a64:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Even deeper into the rabbit hole: Using the FEL mode to communicate with the the Pine A64&lt;/h3&gt;

&lt;p&gt;OK. That was fun, wasn&amp;rsquo;t it? Our small experiment with the UART-to-USB connector cable and the SD card image from Andre did give us a first taste of Linux on the Pine.
But that of course is not the real deal. There is still a rocky path to walk before we will have proper Linux support.&lt;/p&gt;

&lt;p&gt;Our path towards more knowledge leads us even deeper into the rabbit hole.&lt;/p&gt;

&lt;p&gt;In order to gain that deeper knowledge we will introduce you to another powerful tool called &lt;a href=&#34;http://linux-sunxi.org/FEL&#34;&gt;FEL&lt;/a&gt; mode.
The FEL mode is a low-level subroutine in the Boot ROM of all Allwinner devices that can be used to gather valuable insights about the Pine.
We will show you shortly how this works.&lt;/p&gt;

&lt;p&gt;Besides gathering intel FEL has another useful application. It allows you to directly boot images via an USB cable from your development computer.
As such it makes the annoying process of flashing and inserting SD cards over and over again obsolete.&lt;/p&gt;

&lt;p&gt;Booting the Pine A64 into FEL mode is really easy. Just leave the SD card slot empty and connect the Pine A64 with an appropriate USB cable  to your computer.
Then power on the Pine. It&amp;rsquo;s important to know that you have to connect to the Pine with a special USB cable to the upper USB port.
That is because only this USB port is wired for using the FEL signals.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/upper_usb_port.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can buy such a special USB A-male/A-male cable at &lt;a href=&#34;http://www.amazon.com/Monoprice-1-5-Feet-24AWG-Plated-105441/dp/B009GUXG92&#34;&gt;Amazon&lt;/a&gt; or &lt;a href=&#34;http://www.instructables.com/id/Male-to-Male-A-to-A-USB-Cable/&#34;&gt;build it on your own&lt;/a&gt;.
Once the Pine A64 is booted, it can be discovered on your host computer as a new USB device with the &lt;code&gt;USB ID 1f3a:efe8&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Running &lt;code&gt;lsusb&lt;/code&gt; should show the device:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ lsusb
Bus 001 Device 004: ID 1f3a:efe8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For further access via FEL mode, we need to install and compile the very latest version of the sunxi-tools.
As our development computer we are using a Raspberry Pi running &lt;a href=&#34;http://blog.hypriot.com/post/just-in-time-for-DockerCon-EU-a-shipload-of-new-Docker-ARM-goodies/&#34;&gt;HypriotOS&lt;/a&gt;.
So let&amp;rsquo;s install all the development dependencies we need and then clone the sunxi-tools repo and compile them from source.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y make gcc pkg-config libusb-1.0-0-dev
$ makedir -p ~/code
$ cd ~/code
$ git clone https://github.com/linux-sunxi/sunxi-tools
$ cd sunxi-tools
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s see if we can use the sunxi-tools to extract some version information about the Pine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel version
AWUSBFEX soc=00001689(unknown) 00000001 ver=0001 44 08 scratchpad=00017e00 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bingo! The Pine A64 board is connected and we are already getting some basic version info.
The the SOC ID #1689 tells us it is an Allwinner A64 SOC.
The device itself is classified as &amp;ldquo;unknown&amp;rdquo; because it is too new to be recognized by the &lt;code&gt;sunxi-fel&lt;/code&gt; tool.&lt;/p&gt;

&lt;p&gt;What can we do now with this low-level access via FEL mode?&lt;/p&gt;

&lt;p&gt;Well, for instance we could read 128 bytes of the device memory and display it as hex dump on the screen.
Let&amp;rsquo;s start from address 0x0000:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel hexdump 0x0000 128
00000000: 08 00 00 ea 06 00 00 ea 05 00 00 ea 04 00 00 ea  ................
00000010: 03 00 00 ea 02 00 00 ea 11 00 00 ea 00 00 00 ea  ................
00000020: 13 00 00 ea fe ff ff ea 01 00 a0 e3 00 10 a0 e3  ................
00000030: 00 20 a0 e3 00 30 a0 e3 00 40 a0 e3 00 50 a0 e3  . ...0...@...P..
00000040: 00 60 a0 e3 00 70 a0 e3 00 80 a0 e3 00 90 a0 e3  .`...p..........
00000050: 00 a0 a0 e3 00 b0 a0 e3 00 c0 a0 e3 00 d0 a0 e3  ................
00000060: e8 f0 9f e5 04 e0 4e e2 ff 5f 2d e9 1f 07 00 eb  ......N.._-.....
00000070: ff 9f fd e8 d2 20 a0 e3 02 f0 21 e1 d0 d0 9f e5  ..... ....!.....
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we could just copy the device memory into a file to our development computer and display the content with the &lt;code&gt;hexdump&lt;/code&gt; command locally.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel dump 0x0000 128 &amp;gt; memory-dump.bin
$ hexdump -C memory-dump.bin
00000000  08 00 00 ea 06 00 00 ea  05 00 00 ea 04 00 00 ea  |................|
00000010  03 00 00 ea 02 00 00 ea  11 00 00 ea 00 00 00 ea  |................|
00000020  13 00 00 ea fe ff ff ea  01 00 a0 e3 00 10 a0 e3  |................|
00000030  00 20 a0 e3 00 30 a0 e3  00 40 a0 e3 00 50 a0 e3  |. ...0...@...P..|
00000040  00 60 a0 e3 00 70 a0 e3  00 80 a0 e3 00 90 a0 e3  |.`...p..........|
00000050  00 a0 a0 e3 00 b0 a0 e3  00 c0 a0 e3 00 d0 a0 e3  |................|
00000060  e8 f0 9f e5 04 e0 4e e2  ff 5f 2d e9 1f 07 00 eb  |......N.._-.....|
00000070  ff 9f fd e8 d2 20 a0 e3  02 f0 21 e1 d0 d0 9f e5  |..... ....!.....|
00000080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we already explained, the Allwinner SOC is starting it&amp;rsquo;s boot process by loading the Boot ROM (&lt;a href=&#34;http://linux-sunxi.org/BROM&#34;&gt;BROM&lt;/a&gt;)
and detects wether it should run a normal boot or start the FEL subroutine.
With the help of FEL mode and the &lt;code&gt;sunxi-fel&lt;/code&gt; tool we can also copy and analyze the BROM boot code itself.&lt;/p&gt;

&lt;p&gt;So, let&amp;rsquo;s download the BROM directly from the Pine and save it into a local file on our development computer for later inspection.
In order to do so, we need to know the memory address where the BROM starts.&lt;/p&gt;

&lt;p&gt;Unfortunately the memory address that works for existing Allwinner SoC&amp;rsquo;s like the A10 or A20 does not work here.
But there is an important clue in the &lt;a href=&#34;http://linux-sunxi.org/EGON&#34;&gt;Linux-Sunxi wiki&lt;/a&gt; that tells us
that we need to search for a unique string &lt;code&gt;eGON.BRM&lt;/code&gt; near the starting address of the BROM.&lt;/p&gt;

&lt;p&gt;Armed with this knowledge and the &lt;code&gt;sunxi-fel hexdump&lt;/code&gt; command we can now scan the memory until we will find this string.
And luckily we were able to locate the BROM starting at address &lt;strong&gt;0x2c00&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel hexdump 0x2c00 128
00002c00: 07 00 00 ea 07 00 00 ea 65 47 4f 4e 2e 42 52 4d  ........eGON.BRM
00002c10: 24 00 00 00 31 31 30 30 31 31 30 30 31 36 33 33  $...110011001633
00002c20: 00 00 00 00 00 00 00 ea 01 00 00 ea 00 60 a0 e3  .............`..
00002c30: 03 00 00 ea 5c 60 a0 e3 0e 00 00 ea e8 01 9f e5  ....\`..........
00002c40: 00 f0 90 e5 b0 0f 10 ee 03 10 00 e2 00 00 51 e3  ..............Q.
00002c50: f9 ff ff 1a ff 1c 00 e2 00 00 51 e3 f6 ff ff 1a  ..........Q.....
00002c60: c8 11 9f e5 c8 21 9f e5 00 30 91 e5 03 00 52 e1  .....!...0....R.
00002c70: 00 00 00 1a f0 ff ff ea 50 00 a0 e3 01 00 50 e2  ........P.....P.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s download the complete 32 KByte of the BROM binary blob and have a look at it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel dump 0x2c00 32768 &amp;gt; pine64-a64-brom.bin
$ head -c 128 pine64-a64-brom.bin | hexdump -C
00000000  07 00 00 ea 07 00 00 ea  65 47 4f 4e 2e 42 52 4d  |........eGON.BRM|
00000010  24 00 00 00 31 31 30 30  31 31 30 30 31 36 33 33  |$...110011001633|
00000020  00 00 00 00 00 00 00 ea  01 00 00 ea 00 60 a0 e3  |.............`..|
00000030  03 00 00 ea 5c 60 a0 e3  0e 00 00 ea e8 01 9f e5  |....\`..........|
00000040  00 f0 90 e5 b0 0f 10 ee  03 10 00 e2 00 00 51 e3  |..............Q.|
00000050  f9 ff ff 1a ff 1c 00 e2  00 00 51 e3 f6 ff ff 1a  |..........Q.....|
00000060  c8 11 9f e5 c8 21 9f e5  00 30 91 e5 03 00 52 e1  |.....!...0....R.|
00000070  00 00 00 1a f0 ff ff ea  50 00 a0 e3 01 00 50 e2  |........P.....P.|
00000080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All these examples were based on the FEL mode and the &lt;code&gt;sunxi-fel&lt;/code&gt; tool.
They illustrated how to gather information about a device.&lt;/p&gt;

&lt;p&gt;In the introduction about the FEL mode we did mention another application of the FEL mode: You can have a faster development cycle where one does not have to flash and boot SD cards.&lt;/p&gt;

&lt;p&gt;To make this mode work for the Pine we first have to patch the &lt;code&gt;sunix-fel&lt;/code&gt; tool.
Thanks to the work of &lt;a href=&#34;https://github.com/ssvb&#34;&gt;Siarhei Siamashka&lt;/a&gt; from Linux-Sunxi community this is easy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd ~/code/sunxi-tools
$ mv fel.c fel.c.org
$ wget https://github.com/ssvb/sunxi-tools/raw/dc77476014669a6f9010a3160357391450a5196e/fel.c
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, it works. The &lt;code&gt;sunxi-fel&lt;/code&gt; tool now correctly detects the Pine A64 and the Allwinner A64 SOC.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel version
AWUSBFEX soc=00001689(A64) 00000001 ver=0001 44 08 scratchpad=00017e00 00000000 00000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this preparation in place our work on things like the Secondary Program Loader (SPL or boot0), U-Boot, the Linux kernel and its modules get much more convenient.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/pine-a64/dev-host-pine-cabeling.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;inside-wonderland-combining-uart0-console-and-fel-mode:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;Inside wonderland: Combining UART0 console and FEL mode&lt;/h3&gt;

&lt;p&gt;Now it is time to put the various things together we have learned thus far.
Using both an USB A-male/A-male cable and an UART-to-USB connector cable at the same time we are able to send software to the Pine and see how it gets executed.
This allows for fast feedback cycles.&lt;/p&gt;

&lt;p&gt;We will attempt this by uploading and starting a boot0 bootloader.&lt;/p&gt;

&lt;p&gt;Instead of creating our own boot0 bootloader for the sake of simplicity we are going to extract the existing one from Andre&amp;rsquo;s Linux SD card image.
It is located at sector 16 (or 8 KByte) and has a total size of 64 sectors or 32 KByte.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ xzcat pine64_linux-20160121.img.xz | dd of=pine64-boot0.bin bs=512 count=64 skip=16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s double-check if this file is really the correct boot0 binary blob we&amp;rsquo;re looking for.
The file should start with the string &amp;ldquo;eGON.BT0&amp;rdquo; at byte #5. Here we are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hexdump -C pine64-boot0.bin
00000000  cc 00 00 ea 65 47 4f 4e  2e 42 54 30 31 7a f6 a8  |....eGON.BT01z..|
00000010  00 80 00 00 30 00 00 00  00 00 00 00 00 00 01 00  |....0...........|
00000020  00 00 01 00 00 00 00 00  00 00 34 2e 30 2e 30 00  |..........4.0.0.|
00000030  00 00 00 00 01 00 00 00  a0 02 00 00 03 00 00 00  |................|
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the help of &lt;code&gt;sunxi-fel&lt;/code&gt; this boot0 program can now be sent directly to the Pine A64.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo sunxi-fel spl pine64-boot0.bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at our UART0 console output we can see that the upload and start of the program works as expected.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HELLO! BOOT0 is starting!
boot0 commit : 045061a8bb2580cb3fa02e301f52a015040c158f

boot0 version : 4.0.0
set pll start
set pll end
rtc[0] value = 0x00000000
rtc[1] value = 0x00000000
rtc[2] value = 0x00000000
rtc[3] value = 0x00000000
rtc[4] value = 0x00000000
rtc[5] value = 0x00000000
DRAM driver version: V1.1
rsb_send_initseq: rsb clk 400Khz -&amp;gt; 3Mhz
PMU: AXP81X
ddr voltage = 1500 mv
DRAM Type = 3 (2:DDR2,3:DDR3,6:LPDDR2,7:LPDDR3)
DRAM clk = 672 MHz
DRAM zq value: 003b3bbb
DRAM single rank full DQ OK
DRAM size = 1024 MB
DRAM init ok
dram size =1024
card boot number = 0, boot0 copy = 0
card no is 0
sdcard 0 line count 4
[mmc]: mmc driver ver 2015-05-08 20:06
[mmc]: sdc0 spd mode error, 2
[mmc]: Wrong media type 0x00000000
[mmc]: ***Try SD card 0***
[mmc]: mmc 0 cmd 8 timeout, err 00000100
[mmc]: mmc 0 cmd 8 err 00000100
[mmc]: mmc 0 send if cond failed
[mmc]: mmc 0 cmd 55 timeout, err 00000100
[mmc]: mmc 0 cmd 55 err 00000100
[mmc]: mmc 0 send app cmd failed
[mmc]: ***Try MMC card 0***
[mmc]: mmc 0 cmd 1 timeout, err 00000100
[mmc]: mmc 0 cmd 1 err 00000100
[mmc]: mmc 0 send op cond failed
[mmc]: mmc 0 Card did not respond to voltage select!
[mmc]: ***SD/MMC 0 init error!!!***
[mmc]: mmc 0 register failed
Fail in Init sdmmc.
Ready to disable icache.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By verifying that we can send code to the Pine and execute it, we opened up the door for further steps.
For instance working on a new U-Boot bootloader.&lt;/p&gt;

&lt;p&gt;A few days ago Siarhei was able to create a first working U-Boot for the A64 SOC and could upload and start it on his Pine A64 board.
He published the full boot log of this &lt;a href=&#34;https://gist.github.com/ssvb/67ebb38e8f8f2b9b5ee6&#34;&gt;work-in-progress U-Boot bootloader&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here you can see a snippet from the boot log that shows what is already working:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;U-Boot SPL 2016.01-00352-ge77e0e4-dirty (Jan 24 2016 - 10:26:33)
DRAM:DRAM driver version: V1.0
DRAM Type = 3 (2:DDR2,3:DDR3,6:LPDDR2,7:LPDDR3)
DRAM clk = 672 MHz
DRAM zq value: 3b3bbb
DRAM single rank full DQ OK
DRAM size = 1024 MB
DRAM init ok
 1024 MiB
Trying to boot from MMC


U-Boot 2016.01-00352-ge77e0e4-dirty (Jan 24 2016 - 10:26:33 +0200) Allwinner Technology

CPU:   Allwinner A64 (SUN50I)
DRAM:  1 GiB
MMC:   SUNXI SD/MMC: 0
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-preliminary-end:7983295b98b0feead04ba41a7de6ce9d&#34;&gt;The preliminary end&lt;/h2&gt;

&lt;p&gt;This brings us (somewhat sadly) to the end of our blog post.&lt;/p&gt;

&lt;p&gt;Our goal was to give a first impression of the current state of Linux support for the Pine A64.
And we also wanted to give you an introduction to the tools and knowledge that are necessary to make it happen.&lt;/p&gt;

&lt;p&gt;This blogpost would not be possible without the great guys from the Linux-Sunxi community.
Especially the help of &lt;a href=&#34;https://github.com/apritzel&#34;&gt;Andre Przywara&lt;/a&gt; (apritzel) and &lt;a href=&#34;https://github.com/ssvb&#34;&gt;Siarhei Siamashka&lt;/a&gt; (ssvb) was invaluable.
It demands lots of respect seeing how they have to reverse engineer this stuff with only little support from Allwinner Technology.
We really hope that the &lt;a href=&#34;http://forum.pine64.org/forumdisplay.php?fid=17&#34;&gt;announced support&lt;/a&gt; from the Pine team will help to move things forward.&lt;/p&gt;

&lt;p&gt;We will follow this development closely and hope to publish an initial support for HypriotOS rather sooner than later.
By this Docker will gain access to a really powerful developer board - and we will support it early on.&lt;/p&gt;

&lt;p&gt;We hope you enjoyed this whirlwind tour through the Pine Linux Wonderland!&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback, discuss this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=10973751&#34;&gt;HackerNews&lt;/a&gt; and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; and Govinda &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@_beagile_&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to get Docker working on your favourite ARM board with HypriotOS</title>
      <link>http://localhost:1313/post/how-to-get-docker-working-on-your-favourite-arm-board-with-hypriotos/</link>
      <pubDate>Mon, 18 Jan 2016 16:00:00 +0200</pubDate>
      
      <guid>http://localhost:1313/post/how-to-get-docker-working-on-your-favourite-arm-board-with-hypriotos/</guid>
      <description>&lt;p&gt;It all began when Dieter aka &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt; started to experiment with the NVIDIA ShieldTV.
The ShieldTV is a curious little thing. Sold as a media hub for your living room it does deliver one teraflop of processing power.
On top of that it is one of the first 64-bit ARM boards that can be bought for a reasonable price.&lt;/p&gt;

&lt;p&gt;Regular readers of our blog know that it is not in Dieter&amp;rsquo;s nature to resist the Sirens voices of such an appealing beauty for long.
Read on to learn what happened next&amp;hellip;&lt;/p&gt;

&lt;p&gt;Last December he started the work to get Docker running on the ShieldTV and &lt;a href=&#34;http://blog.hypriot.com/post/getting-docker-running-on-a-highend-arm-gaming-console-for-fun-and-profit/&#34;&gt;described his journey&lt;/a&gt; on our blog.
The gist of it is that it was quite an involved process of creating his own custom Debian based operating system that supported building Go and Docker for ARM64.&lt;/p&gt;

&lt;p&gt;The work of Dieter on the ShieldTV inspired our team to revisit the way we were building our beloved HypriotOS for the Raspberry Pi.
Longing to publish the way we build it for quite some time we had been ashamed to actually do it because it was such a complicated mess.
Don&amp;rsquo;t get me wrong - it worked well enough and was completely automated with our CI system and even tested, but ultimately it was difficult to understand and change.&lt;/p&gt;

&lt;p&gt;So Dieter&amp;rsquo;s work got us thinking:
What if we could restructure the build process of HypriotOS in such a way that it would be built in distinct layers that would create distinct build artifacts on their own.
What if those artifacts could be tested and published on their own, too? Only to be assembled in a final step at the end to create a fully working SD card image.
What if those distinct steps were self-contained and easy to understand?&lt;/p&gt;

&lt;p&gt;Last week we had some time at our hands and we started working on a build process that would be the answer to all those questions.
It is certainly still a little rough around the edges and needs further tweaking but it produces a working SD card image for the Raspberry Pi.
We consider it beta quality and it is not yet completely on par with our stable HypriotOS Hector image, but it already runs very well.&lt;/p&gt;

&lt;p&gt;The main repository for building HypriotOS SD card image for the Raspberry Pi can be found at GitHub in the &lt;a href=&#34;https://github.com/hypriot/image-builder-rpi&#34;&gt;Image-Builder-Rpi Repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So what happens in this repository?&lt;/p&gt;

&lt;p&gt;Basically it just assembles prepared artifacts into a working SD card image which then can be &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;easily flashed&lt;/a&gt; onto a SD card.&lt;/p&gt;

&lt;p&gt;The artifacts that are combined here are produced elsewhere each in their own GitHub repository:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/os-rootfs&#34;&gt;a basic filesystem that is based on Debian Jessie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/rpi-kernel&#34;&gt;a Raspberry Pi compatible Linux kernel and firmware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-raw&#34;&gt;a Raspberry Pi image file that contains the necessary partitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://packagecloud.io/Hypriot/Schatzkiste&#34;&gt;a couple of Debian packages with software like Docker, Docker-Machine and Docker-Compose&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The basic idea is that all these artifacts can be build and tested with the help of Docker.
For instance if you look into the &lt;a href=&#34;https://github.com/hypriot/os-rootfs&#34;&gt;os-rootfs&lt;/a&gt; repository you will find a &lt;code&gt;Dockerfile&lt;/code&gt; in the root of the project that will allow you to create a build and test environment for the root filesystem.&lt;/p&gt;

&lt;p&gt;This makes two important things possible: Firstly it allows others to build the rootfs locally on their own computer and fix or extend the rootfs with ease.
And secondly the rootfs is build and tested on &lt;a href=&#34;https://travis-ci.org/hypriot/os-rootfs&#34;&gt;Travis CI&lt;/a&gt; everytime somebody creates - for instance - a pull request.
Combined these two points create a transparent development process with instant feedback.&lt;/p&gt;

&lt;p&gt;It turned out that this approach is generic and powerful enough to be applied - you probably already guessed it - to the NVIDIA ShieldTV, too.
By publishing the &lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv&#34;&gt;Image-Builder-NVIDIA-ShieldTV&lt;/a&gt; repository we are making good on Dieter&amp;rsquo;s promise to publish the sources for Dieter&amp;rsquo;s journey with the ShieldTV.&lt;/p&gt;

&lt;p&gt;But hold on - that&amp;rsquo;s not all. To proof to ourselves that this process allows to easily port HypriotOS to different development boards we created &lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1&#34;&gt;another Github repository&lt;/a&gt;.
It builds a SD card image for the very capable &lt;a href=&#34;http://www.hardkernel.com/main/products/prdt_info.php?g_code=G143703355573&#34;&gt;ODROID C1+&lt;/a&gt; development board.
Similar to the Raspberry Pi 2 the ODROID C1+ features a quad core ARMv7 CPU with 1 GB of memory. Distinct from the Raspberry Pi 2 it features a gigabit ethernet port.
A highlevel comparision of both devices can be found at &lt;a href=&#34;http://www.cnx-software.com/2015/02/02/raspberry-pi-2-odroid-c1-development-boards-comparison/&#34;&gt;CNX-Software&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this third supported board for HypriotOS we proofed to ourselves that this new build process makes it not only feasible but actually quite easy to extend the support of HypriotOS to new development boards.&lt;/p&gt;

&lt;p&gt;Overall the relation of the different repositories now looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/hypriotos-xxx/hypriotos_buildpipeline.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All these changes also redefined for us what HypriotOS is all about.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our old mission statement for HypriotOS was:&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&amp;ldquo;HypriotOS is a minimal operating system for the Raspberry Pi 1 &amp;amp; 2 that provides an optimized environment for running Docker. It is very easy to install and use. HypriotOS prides itself for coming with very recent versions of the Linux kernel and all included software.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Our new mission statement is:&lt;/strong&gt;&lt;br /&gt;
&lt;em&gt;&amp;ldquo;HypriotOS is a minimal Debian-based operating system for &lt;strong&gt;many popular IoT devices&lt;/strong&gt; that provides an optimized environment for running Docker. It is very easy to install and use. HypriotOS prides itself for coming with very recent versions of the Linux kernel and all included software.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It is just a small change but it will have big implications.&lt;/p&gt;

&lt;p&gt;One of the biggest downsides of having an ever increasing amount of IoT devices to choose from is fragmentation. Each device comes with varying support for existing operating systems.
Take Linux for instance. Even if a vendor provides Linux support for a device from the start - it is often based on an outdated Linux kernel.
This in turn often enough means that you can only use old software on top of it. Docker with OverlayFS is such an example. It can only be used with a Linux kernel greater than 3.18.
And that&amp;rsquo;s not only a problem of the small vendors, it even happens with big vendors like NVIDIA. The NVIDIA ShieldTV is provided only with a 3.10 Linux kernel while the latest stable Linux kernel is 4.4.
Not to mention that the 3.10 kernel is &lt;a href=&#34;https://www.kernel.org/category/releases.html&#34;&gt;not supported any more by the kernel maintainers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With this background in mind a major goal of HypriotOS is to provide an operating system that behaves as similar as possible on &lt;strong&gt;different&lt;/strong&gt; IoT devices.
While I know that this might prove to be a difficult task - especially in regards to support for recent Linux kernels - I think it might prove to be a worthwhile effort that provides much value.&lt;/p&gt;

&lt;p&gt;Providing a beta version of HypriotOS that supports three different development boards is a first step into that direction.&lt;/p&gt;

&lt;p&gt;Being just able to flash HypriotOS on a SD card and get going in minutes is one of the basic promises of HypriotOS, so without further ado you can download it here:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/hypriot/image-builder-rpi/releases&#34;&gt;HypriotOS for the Raspberry Pi&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/image-builder-nvidia-shieldtv/releases&#34;&gt;HypriotOS for the NVIDIA ShieldTV&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/hypriot/image-builder-odroid-c1/releases&#34;&gt;HypriotOS for the ODROID C1+&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hopefully you have a lot of fun trying out what HypriotOS has to offer!&lt;br /&gt;
&lt;strong&gt;Note:&lt;/strong&gt; We changed the default username to &lt;code&gt;pirate&lt;/code&gt; (password &lt;code&gt;hypriot&lt;/code&gt;) and disabled the &lt;code&gt;root&lt;/code&gt; user for security reasons.&lt;/p&gt;

&lt;p&gt;By adding support for many more boards we think HypriotOS gets a lot more attractive! What do you think?&lt;br /&gt;
And for which board would you want to see support next?
Help us to get your favourite ARM board supported by HypriotOS!&lt;/p&gt;

&lt;p&gt;As always use the comments below to give us feedback and share it on Twitter or Facebook.
You also might wanna discuss this article on &lt;a href=&#34;https://news.ycombinator.com/item?id=10926502&#34;&gt;HackerNews&lt;/a&gt; or vote it up if you find it interesting.&lt;/p&gt;

&lt;p&gt;Govinda aka &lt;a href=&#34;https://twitter.com/_beagile_&#34;&gt;@&lt;em&gt;beagile&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>First Meetup at University of Bamberg summons local Docker community</title>
      <link>http://localhost:1313/post/first_docker_meetup_university_bamberg/</link>
      <pubDate>Fri, 15 Jan 2016 21:47:24 +0100</pubDate>
      
      <guid>http://localhost:1313/post/first_docker_meetup_university_bamberg/</guid>
      <description>&lt;p&gt;&lt;strong&gt;An introduction to Docker, hands-on tutorials, live demos and roughly 30 attendees.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is the summary of the first Docker meetup that we organized in cooperation with University of Bamberg. As a supplement to this event yesterday, we share the pictures and the slides of the presentation.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;gallery clearfix&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;





&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_00.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_00.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Our self-made poster&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Our self-made poster
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_01.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_01.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Some introductory words by Marcel Großmann as representer of the University&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Some introductory words by Marcel Großmann as representer of the University
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_02.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_02.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;... and Mathias with introductory words for Hypriot.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    ... and Mathias with introductory words for Hypriot.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Docker Inc.&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_03.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_03.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Introduction to Docker: Knowing about the evolution of virtualization helps to understand Docker.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Introduction to Docker: Knowing about the evolution of virtualization helps to understand Docker.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_04.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_04.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Community is carefully listening.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Community is carefully listening.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_05.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_05.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;While everyone is playing with Docker the entire Hypriot team is around to help.&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    While everyone is playing with Docker the entire Hypriot team is around to help.
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;




&lt;figure itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;
  &lt;a href=&#34;http://localhost:1313/images/meetup_uni_bamberg/docker_meetup_university_bamberg_06.jpg&#34; itemprop=&#34;contentUrl&#34; data-size=&#34;1030x684&#34;&gt;
      &lt;img src=&#34;http://localhost:1313/images/meetup_uni_bamberg/thumbnails/thumb_docker_meetup_university_bamberg_06.jpg&#34; itemprop=&#34;thumbnail&#34; alt=&#34;Mathias announcing a live demo with Hypriot Cluster Lab presented by Andreas (in the middle).&#34; /&gt;
  &lt;/a&gt;


  &lt;figcaption itemprop=&#34;caption description&#34;&gt;
    Mathias announcing a live demo with Hypriot Cluster Lab presented by Andreas (in the middle).
    &lt;span itemprop=&#34;copyrightHolder&#34;&gt;Dieter Reuter&lt;/span&gt;
  &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/photoswipe.css&#34;&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;http://localhost:1313/css/default-skin/default-skin.css&#34;&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/photoswipe-ui-default.min.js&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;http://localhost:1313/js/initphotoswipe.js&#34;&gt;&lt;/script&gt;



&lt;div class=&#34;pswp&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34; aria-hidden=&#34;true&#34;&gt;

&lt;div class=&#34;pswp__bg&#34;&gt;&lt;/div&gt;

&lt;div class=&#34;pswp__scroll-wrap&#34;&gt;
    
    &lt;div class=&#34;pswp__container&#34;&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
      &lt;div class=&#34;pswp__item&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div class=&#34;pswp__ui pswp__ui--hidden&#34;&gt;
    &lt;div class=&#34;pswp__top-bar&#34;&gt;
      
      &lt;div class=&#34;pswp__counter&#34;&gt;&lt;/div&gt;
      &lt;button class=&#34;pswp__button pswp__button--close&#34; title=&#34;Close (Esc)&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--share&#34; title=&#34;Share&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--fs&#34; title=&#34;Toggle fullscreen&#34;&gt;&lt;/button&gt;
      &lt;button class=&#34;pswp__button pswp__button--zoom&#34; title=&#34;Zoom in/out&#34;&gt;&lt;/button&gt;
      
      
      &lt;div class=&#34;pswp__preloader&#34;&gt;
        &lt;div class=&#34;pswp__preloader__icn&#34;&gt;
          &lt;div class=&#34;pswp__preloader__cut&#34;&gt;
            &lt;div class=&#34;pswp__preloader__donut&#34;&gt;&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&#34;pswp__share-modal pswp__share-modal--hidden pswp__single-tap&#34;&gt;
      &lt;div class=&#34;pswp__share-tooltip&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--left&#34; title=&#34;Previous (arrow left)&#34;&gt;
    &lt;/button&gt;
    &lt;button class=&#34;pswp__button pswp__button--arrow--right&#34; title=&#34;Next (arrow right)&#34;&gt;
    &lt;/button&gt;
    &lt;div class=&#34;pswp__caption&#34;&gt;
      &lt;div class=&#34;pswp__caption__center&#34;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;style&gt;
    .gallery {  }
    .gallery img { width: 100%; height: auto; }
    .gallery figure { display: block; float: left; margin: 0 5px 5px 0; width: 200px; }
    .gallery figcaption { display: none; }
    .gallery div.title { font-weight: bold; }
    span[itemprop=&#34;copyrightHolder&#34;] { color : #888; float: right; }
    span[itemprop=&#34;copyrightHolder&#34;]:before { content: &#34;Foto: &#34;; }
    img[itemprop=&#34;thumbnail&#34;]{ width: 200px; }
&lt;/style&gt;


&lt;script&gt;initPhotoSwipeFromDOM(&#39;.gallery&#39;);&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;And here the slides of the presentation:&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/79aLKAZjsSsL5i&#34; width=&#34;595&#34; height=&#34;485&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Thanks to all guests for coming, hacking, and the good discussions. Special thanks to Prof. Krieger and Marcel Großmann for the awesome support from University.
&lt;br /&gt;&lt;br /&gt;
The next Docker Meetup will take place on February the 25th. Save the date! &lt;a href=&#34;http://www.meetup.com/Docker-Bamberg/&#34;&gt;Details are available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://twitter.com/MathiasRenner&#34;&gt;@MathiasRenner&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to compile Go on any ARM device</title>
      <link>http://localhost:1313/post/how-to-compile-go-on-arm/</link>
      <pubDate>Thu, 31 Dec 2015 18:47:24 +0100</pubDate>
      
      <guid>http://localhost:1313/post/how-to-compile-go-on-arm/</guid>
      <description>

&lt;p&gt;As for today, up to the latest Go version 1.5.2 there is no official binary release
of the Go runtime available for ARM devices. Maybe you can install it as
a package from your operating system, but these packages are almost outdated.&lt;/p&gt;

&lt;p&gt;For this reason, anyone who wants to use GOLANG (or Go for short) on an ARM device has to compile
it by himself. This is a cumbersome and time consuming task, which sometimes leads
to bad results.&lt;/p&gt;

&lt;p&gt;To cover these issues, we&amp;rsquo;ll explain in this short and basic tutorial how to compile
and test the Go compiler runtime by yourself. We&amp;rsquo;d like to cover all the details you&amp;rsquo;ll
need from the ground up. And with having this basic understanding then it&amp;rsquo;s easier
for everybody to build and use the Go compiler in a consistent and reproducible way.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s get started with building your own Go environment on ARM&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;let-s-go-on-arm:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Let&amp;rsquo;s Go on ARM&lt;/h3&gt;

&lt;p&gt;As a member of the Hypriot team I&amp;rsquo;ll show you all the necessary steps on a
Raspberry Pi 2 board. Together we&amp;rsquo;ll first install the operating system with
flashing a SD card with HypriotOS and then installing all the build tools we&amp;rsquo;ll
need to bootstrap a complete Go development environment.&lt;/p&gt;

&lt;p&gt;These steps are quite similar for almost every other Linux distro, so I&amp;rsquo;m assuming you&amp;rsquo;ll
need just a short time to adjust the build steps for any Ubuntu, Debian, ArchLinux
or other Linux OS on your ARM device of choice.&lt;/p&gt;

&lt;h3 id=&#34;bootstrap-the-building-system:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Bootstrap the building system&lt;/h3&gt;

&lt;p&gt;We need the following parts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Raspberry Pi 2 Model B&lt;/li&gt;
&lt;li&gt;a SD card with 4Gbyte or larger&lt;/li&gt;
&lt;li&gt;a power adapter or an USB cable to power the Raspberry Pi&lt;/li&gt;
&lt;li&gt;an ethernet cable to connect the Raspberry Pi to the internet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As soon as you have setup the hardware, we can start to install the OS and login
to our fresh and clean build system.&lt;/p&gt;

&lt;h4 id=&#34;a-flash-a-new-sd-card-with-hypriotos-0-6-1:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;a) Flash a new SD card with HypriotOS 0.6.1&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m using a Mac to flash the SD card, so maybe you have to look for specific
instructions for your OS in one of our other posts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ wget http://downloads.hypriot.com/hypriot-rpi-20151115-132854.img.zip
$ tar -xvf hypriot-rpi-20151115-132854.img.zip
$ flash --hostname golang-nutshell hypriot-rpi-20151115-132854.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-boot-the-raspberry-pi-2-with-hypriotos:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;b) Boot the Raspberry Pi 2 with HypriotOS&lt;/h4&gt;

&lt;p&gt;Just insert the SD card into your Raspberry Pi 2, connect the Ethernet cable
between the Raspi and your Internet router/switch and power on the Raspi.&lt;/p&gt;

&lt;p&gt;Within one or two minutes the Raspi is booted and has already configured the SD card
for the first time to it&amp;rsquo;s full size. We defined the specific hostname &lt;code&gt;golang-nutshell&lt;/code&gt;
for the Raspi, so we can lookup the device on our network.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ping -c 3 golang-nutshell.local

PING golang-nutshell.local (192.168.2.116): 56 data bytes
64 bytes from 192.168.2.116: icmp_seq=0 ttl=64 time=5.337 ms
64 bytes from 192.168.2.116: icmp_seq=1 ttl=64 time=6.142 ms
64 bytes from 192.168.2.116: icmp_seq=2 ttl=64 time=6.781 ms

--- golang-nutshell.local ping statistics ---
3 packets transmitted, 3 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 5.337/6.087/6.781/0.591 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-prepare-ssh-for-login:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;c) Prepare SSH for login&lt;/h4&gt;

&lt;p&gt;In case you used the same hostname or IP address before, you should clean your
SSH cache with the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-keygen -R golang-nutshell.local
$ ssh-keygen -R 192.168.2.116
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, login to your Raspi with the standard username=&lt;code&gt;pi&lt;/code&gt; and password=&lt;code&gt;raspberry&lt;/code&gt;,
or you can optionally just setup SSH with your SSH credentials.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh-copy-id pi@golang-nutshell.local
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;d-login-to-your-raspberry-pi:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;d) Login to your Raspberry Pi&lt;/h4&gt;

&lt;p&gt;Once the Raspi and SSH access is configured, we can login and start working on
our task to compile Go from the source code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh pi@golang-nutshell.local
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;e-install-all-the-required-build-dependencies:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;e) Install all the required build dependencies&lt;/h4&gt;

&lt;p&gt;In order to build Go 1.5 we need first a running Go 1.4 compiler on our system.
So, we&amp;rsquo;ll start our journey with building the Go 1.4 compiler first.&lt;/p&gt;

&lt;p&gt;Next we have to consider that Go 1.4.x has to be built with a &lt;code&gt;gcc&lt;/code&gt; compiler,
because the Go 1.4 compiler is written in C code.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s install all the necessary build dependencies. Some of these packages are
already pre-installed with HypriotOS, but I&amp;rsquo;d like to list all of them here so you
can easily replay this tutorial on a different Linux distro as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo apt-get update
$ sudo apt-get install -y curl gcc git-core
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;download-go-1-4-3-source-tarball-and-compile-it:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Download Go 1.4.3 source tarball and compile it&lt;/h3&gt;

&lt;p&gt;The GOLANG team provides all the Go sources for all the different versions as
easy to download and install tarballs. But it&amp;rsquo;s not clearly documented how to compile
and package it the right way to get a package for a binary release later on.&lt;/p&gt;

&lt;p&gt;Ok, so let&amp;rsquo;s explain these steps in detail and you&amp;rsquo;ll get to know all the important
parts. After all it&amp;rsquo;s just easy to make some mistakes and so we&amp;rsquo;ll try to break
the steps down for easy understanding.&lt;/p&gt;

&lt;h4 id=&#34;a-download-the-go-1-4-3-source-code:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;a) Download the Go 1.4.3 source code&lt;/h4&gt;

&lt;p&gt;Maybe some of you will be asking, why I&amp;rsquo;m extracting the Go source code into the
directory &lt;code&gt;/usr/local/go&lt;/code&gt; and running the gcc compiler as a &lt;code&gt;root&lt;/code&gt; user.
I&amp;rsquo;m coming back later on to the reasons behind, but for now you should know it&amp;rsquo;s just
important for creating the binary package.&lt;/p&gt;

&lt;p&gt;You can see, I&amp;rsquo;m downloading the source tarball and extract it right away in a
single step, but if you like you can break this into two steps as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ curl -sSL https://storage.googleapis.com/golang/go1.4.3.src.tar.gz | sudo tar -xz -C /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively using two steps:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ curl -O https://storage.googleapis.com/golang/go1.4.3.src.tar.gz
$ sudo tar -xzf go1.4.3.src.tar.gz -C /usr/local
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;b-compile-go-1-4-3-without-running-the-tests:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;b) Compile Go 1.4.3 without running the tests&lt;/h4&gt;

&lt;p&gt;We compile Go now from within this installation directory and please we warned
it will take some time. On a Raspberry Pi 2 with it&amp;rsquo;s four ARMv7 cores it&amp;rsquo;s quite fast
enough, but on a slower machine it can take hours!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local/go/src
$ time sudo ./make.bash

# Building C bootstrap tool.
cmd/dist
...
---
Installed Go for linux/arm in /usr/local/go
Installed commands in /usr/local/go/bin

real	10m41.755s
user	12m8.140s
sys	0m46.860s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As soon as we can read the message &lt;code&gt;Installed Go for linux/arm in /usr/local/go&lt;/code&gt;
we know the build was successful and we can use the Go compiler right away.&lt;/p&gt;

&lt;h4 id=&#34;c-test-running-the-go-1-4-3-locally:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;c) Test running the Go 1.4.3 locally&lt;/h4&gt;

&lt;p&gt;According to the fact that we used the standard installation path in &lt;code&gt;/usr/local/go&lt;/code&gt;,
we are now able to use Go 1.4.3 directly on our Raspi. The only thing we need is
to define the PATH variable in order that all the Go tools and programs can be used
from the command line.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ export PATH=/usr/local/go/bin:$PATH
$ go version

go version go1.4.3 linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great, we do have successfully compiled Go 1.4.3 on our Raspberry Pi and can
use it now right away. This process lasts some time and we don&amp;rsquo;t like to repeat
this much often, right? And on the other side, did you recognized that we didn&amp;rsquo;t
run any tests at all?&lt;/p&gt;

&lt;p&gt;Running the Go tests at compile time is quite easy, just run &lt;code&gt;./all.bash&lt;/code&gt; instead
of &lt;code&gt;./make.bash&lt;/code&gt;. But this will take way much longer and typically the tests will
fail on a Raspberry Pi 2 and maybe on other similar devices too. In this case it&amp;rsquo;s
better to compile Go an run the tests on a reliable machine like the
&lt;a href=&#34;https://www.scaleway.com&#34;&gt;Scaleway&lt;/a&gt; cloud servers.&lt;/p&gt;

&lt;h3 id=&#34;package-go-1-4-3-as-a-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Package Go 1.4.3 as a binary tarball&lt;/h3&gt;

&lt;p&gt;Maybe some of you already know, that the GOLANG team is providing Go binary releases
for the most common operating systems. But unfortunately not for ARM.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s create our own Go binary tarball in the exact same way like the originals,
because then it&amp;rsquo;s easier for us using the exact same ways and scripts when
we&amp;rsquo;d like to install it on our new ARM machines as well.&lt;/p&gt;

&lt;h4 id=&#34;a-analyse-the-original-go-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;a) Analyse the original Go binary tarball&lt;/h4&gt;

&lt;p&gt;We can find the official GOLANG binary releases on their download page.
So let&amp;rsquo;s just google for &amp;ldquo;golang download&amp;rdquo; and we&amp;rsquo;ll get to their website
&lt;a href=&#34;https://golang.org/dl/&#34;&gt;Downloads - The Go Programming Language&lt;/a&gt; and select
Go 1.4.3 for a Linux on Intel 64-bit.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl -O https://storage.googleapis.com/golang/go1.4.3.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s analyze the structure of this tarball in more detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -vtf go1.4.3.linux-amd64.tar.gz | head -10
drwxr-xr-x 0/0               0 2015-09-23 06:43 go/
-rw-r--r-- 0/0           17575 2015-09-23 06:37 go/AUTHORS
-rw-r--r-- 0/0           24564 2015-09-23 06:37 go/CONTRIBUTORS
-rw-r--r-- 0/0            1479 2015-09-23 06:37 go/LICENSE
-rw-r--r-- 0/0            1303 2015-09-23 06:37 go/PATENTS
-rw-r--r-- 0/0            1112 2015-09-23 06:37 go/README
-rw-r--r-- 0/0               7 2015-09-23 06:38 go/VERSION
drwxr-xr-x 0/0               0 2015-09-23 06:37 go/api/
-rw-r--r-- 0/0             524 2015-09-23 06:37 go/api/README
-rw-r--r-- 0/0           19302 2015-09-23 06:37 go/api/except.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This tarball has some special settings we should really keep care about it.
First of all, the user and group id&amp;rsquo;s &lt;code&gt;0/0&lt;/code&gt; are all numeric and showing this
is a &lt;code&gt;root/root&lt;/code&gt; user.
Next to notice is that the directory name is always starting with &lt;code&gt;go/&lt;/code&gt; and
without any leading slash &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;These are all just small details, but we have to
make sure, we create our own tarball the same way - otherwise it will work on some
machines and on some we&amp;rsquo;ll get some wired issues, because we don&amp;rsquo;t know which
command a different user will use to install the binary tarball on his machine.&lt;/p&gt;

&lt;h4 id=&#34;b-create-our-own-go-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;b) Create our own Go binary tarball&lt;/h4&gt;

&lt;p&gt;With this details in mind we can create our own binary release tarball easily.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -czf ~/go1.4.3.linux-armv7.tar.gz -C /usr/local go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or alternatively, if your &lt;code&gt;tar&lt;/code&gt; command does not support the &lt;code&gt;-C&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local
$ tar -czf ~/go1.4.3.linux-armv7.tar.gz go
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;c-prove-our-own-go-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;c) Prove our own Go binary tarball&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ tar -vtf go1.4.3.linux-armv7.tar.gz | head -10
drwxr-xr-x root/root         0 2015-12-31 14:06 go/
drwxr-xr-x root/root         0 2015-12-31 14:16 go/bin/
-rwxr-xr-x root/root   7659728 2015-12-31 14:16 go/bin/go
-rwxr-xr-x root/root   2899312 2015-12-31 14:16 go/bin/gofmt
-rw-r--r-- root/root      1303 2015-09-23 06:37 go/PATENTS
-rw-r--r-- root/root      1479 2015-09-23 06:37 go/LICENSE
drwxr-xr-x root/root         0 2015-09-23 06:38 go/test/
-rw-r--r-- root/root       722 2015-09-23 06:37 go/test/sinit_run.go
-rw-r--r-- root/root      2280 2015-09-23 06:37 go/test/nil.go
-rw-r--r-- root/root       716 2015-09-23 06:37 go/test/typeswitch3.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, not exactly the same as the original. The user and group id&amp;rsquo;s are not in numerical form, but all the other details seems to be correct. We just have to include the &lt;code&gt;--numeric-owner&lt;/code&gt; flag and we&amp;rsquo;ll get a perfect result.&lt;/p&gt;

&lt;h4 id=&#34;d-recommended-way-to-package-the-go-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;d) Recommended way to package the Go binary tarball&lt;/h4&gt;

&lt;p&gt;With all the details proved well, we do have now a way how we should package the
Go pre-compiled binary tarball. As long as your ARM Linux system supports the &lt;code&gt;tar&lt;/code&gt;
command with all the necessary flags, we can use this single command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar --numeric-owner -czf ~/go1.4.3.linux-armv7.tar.gz -C /usr/local go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can happen that your &lt;code&gt;tar&lt;/code&gt; version doesn&amp;rsquo;t support the &lt;code&gt;--numeric-owner&lt;/code&gt; flag,
so just leave this out. When your &lt;code&gt;tar&lt;/code&gt; doesn&amp;rsquo;t support the &lt;code&gt;-z&lt;/code&gt; compresssion flag,
it can be done in two steps as well. And if &lt;code&gt;-C&lt;/code&gt; flag isn&amp;rsquo;t supported, we can
work around this too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /usr/local
$ tar --numeric-owner -cf ~/go1.4.3.linux-armv7.tar go
$ gzip ~/go1.4.3.linux-armv7.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, here is our almost perfect own-built pre-compiled Go tarball, which
we could install within just seconds on any of our ARM devices.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -vtf go1.4.3.linux-armv7.tar.gz | head -10
drwxr-xr-x 0/0               0 2015-12-31 14:06 go/
drwxr-xr-x 0/0               0 2015-12-31 14:16 go/bin/
-rwxr-xr-x 0/0         7659728 2015-12-31 14:16 go/bin/go
-rwxr-xr-x 0/0         2899312 2015-12-31 14:16 go/bin/gofmt
-rw-r--r-- 0/0            1303 2015-09-23 06:37 go/PATENTS
-rw-r--r-- 0/0            1479 2015-09-23 06:37 go/LICENSE
drwxr-xr-x 0/0               0 2015-09-23 06:38 go/test/
-rw-r--r-- 0/0             722 2015-09-23 06:37 go/test/sinit_run.go
-rw-r--r-- 0/0            2280 2015-09-23 06:37 go/test/nil.go
-rw-r--r-- 0/0             716 2015-09-23 06:37 go/test/typeswitch3.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;install-and-test-the-go-1-4-3-binary-tarball:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Install and test the Go 1.4.3 binary tarball&lt;/h3&gt;

&lt;p&gt;Honestly, this was a long and dirty road, just to get a Go 1.4.3 compiler so that
we can start developing our Go code and compiling our real world tasks on an
ARM device. But with all these details we know now exactly how to create and package
a Go binary release as a pre-compiled tarball.&lt;/p&gt;

&lt;p&gt;And finally, let&amp;rsquo;s see how easy we do have it now, when we have a Go binary release
for our ARM device available. It&amp;rsquo;s really that damn simple to install Go and just using it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ sudo tar -xzf go1.4.3.linux-armv7.tar.gz -C /usr/local
$ export PATH=/usr/local/go/bin:$PATH
$ go version

go version go1.4.3 linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compiling-testing-and-packaging-go-1-5-2:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Compiling, testing and packaging Go 1.5.2&lt;/h3&gt;

&lt;p&gt;With all our previous detailed work this part is now a really easy task.&lt;/p&gt;

&lt;p&gt;As the first step, before we&amp;rsquo;re able to compile Go 1.5.2 on our ARM board, we have
to install a Go 1.4.3 compiler. Luckily we have already a pre-compiled Go 1.4.3
which we can use here. But we should install it in a different location, which is
the recommended way according to the GOLANG team.&lt;/p&gt;

&lt;p&gt;Install the Go 1.4.3 binary release from our own tarball:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -fr $HOME/go1.4
$ mkdir -p $HOME/go1.4
$ tar -xzf go1.4.3.linux-armv7.tar.gz -C $HOME/go1.4 --strip-components=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can download the Go 1.5.2 source tarball and bootstrap/compile it with Go 1.4.3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ curl -sSL https://storage.googleapis.com/golang/go1.5.2.src.tar.gz | sudo tar -xz -C /usr/local

$ cd /usr/local/go/src
$ time sudo GOROOT_BOOTSTRAP=/home/pi/go1.4 ./make.bash

##### Building Go bootstrap tool.
...
---
Installed Go for linux/arm in /usr/local/go
Installed commands in /usr/local/go/bin

real	11m14.203s
user	26m29.730s
sys	1m18.470s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s package Go 1.5.2 as a binary tarball, using our recommended way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar --numeric-owner -czf ~/go1.5.2.linux-armv7.tar.gz -C /usr/local go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Prove the Go 1.5.2 binary package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tar -vtf go1.5.2.linux-armv7.tar.gz | head -10
drwxr-xr-x 0/0               0 2015-12-31 17:08 go/
drwxr-xr-x 0/0               0 2015-12-31 17:18 go/bin/
-rwxr-xr-x 0/0         9004984 2015-12-31 17:18 go/bin/go
-rwxr-xr-x 0/0         3163768 2015-12-31 17:17 go/bin/gofmt
-rw-r--r-- 0/0            1519 2015-12-03 01:52 go/README.md
-rw-r--r-- 0/0            1303 2015-12-03 01:52 go/PATENTS
-rw-r--r-- 0/0            1479 2015-12-03 01:52 go/LICENSE
drwxr-xr-x 0/0               0 2015-12-03 01:53 go/test/
-rw-r--r-- 0/0             595 2015-12-03 01:53 go/test/sinit_run.go
-rw-r--r-- 0/0            2280 2015-12-03 01:53 go/test/nil.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Install and test the Go 1.5.2 binary tarball&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ sudo tar -xzf go1.5.2.linux-armv7.tar.gz -C /usr/local
$ export PATH=/usr/local/go/bin:$PATH
$ go version

go version go1.5.2 linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wow, this time it was pretty easy and completed with a few commands only.
But we didn&amp;rsquo;t run any tests at all. And honestly, as a developer I just like
to install and use the Go compiler - I don&amp;rsquo;t like to compile it by myself,
so I recommend using a Go binary release would be the best way!&lt;/p&gt;

&lt;h3 id=&#34;key-takeaways:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Key takeaways&lt;/h3&gt;

&lt;p&gt;As you can clearly see, it&amp;rsquo;s really the easiest and preferred way to install a
Go binary release instead of compiling the Go compiler every time from source.
Especially for some slow ARM devices it can take hours and will sometimes lead
to some confusing problems too.&lt;/p&gt;

&lt;p&gt;When you prefer to use a completely tested Go binary release it&amp;rsquo;s even more desired
to use pre-compiled and successfully tested Go versions for ARMv6, ARMv7 and
even later for the 64-bit ARM devices as well.&lt;/p&gt;

&lt;p&gt;The really great news here is, that  the GOLANG team has acknowleged to build
and deliver the future Go releases from version 1.6 on with pre-compiled tarballs - at least
for ARMv6. The difference between ARMv6 and ARMv7 are absolutely marginal for Go,
because the generated machine code doesn&amp;rsquo;t use any advanced instructions from the
ARMv7 instruction set at all and ARMv7 just uses a few more registers - that&amp;rsquo;s all.&lt;/p&gt;

&lt;p&gt;And in the meantime, we&amp;rsquo;ve already done all the hard work for you and created the
Go binary releases for 1.4.3, 1.5.1 and 1.5.2. Everything is open source and
available on our GitHub repo at &lt;a href=&#34;https://github.com/hypriot/golang-armbuilds&#34;&gt;https://github.com/hypriot/golang-armbuilds&lt;/a&gt;. From
here you can easily install a Go binary release within a few minutes with the following commands:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo rm -fr /usr/local/go
$ curl -sSL https://github.com/hypriot/golang-armbuilds/releases/download/v1.5.2/go1.5.2.linux-armv7.tar.gz | sudo tar -xz -C /usr/local
$ export PATH=/usr/local/go/bin:$PATH
$ go version

go version go1.5.2 linux/arm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is already a work in progress and we&amp;rsquo;re happy to get comments and pull-request
to improve the build task even more.&lt;/p&gt;

&lt;h3 id=&#34;feedback-please:204f85c7f3de7b1fb9d7b9a672da8cbd&#34;&gt;Feedback please!&lt;/h3&gt;

&lt;p&gt;Please send us your feedback on our &lt;a href=&#34;https://gitter.im/hypriot/talk&#34;&gt;Gitter channel&lt;/a&gt; or tweet your thoughts and ideas on this tutorial at &lt;a href=&#34;https://twitter.com/HypriotTweets&#34;&gt;@HypriotTweets&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dieter &lt;a href=&#34;https://twitter.com/Quintus23M&#34;&gt;@Quintus23M&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Introducing Hypriot Cluster Lab: Docker clustering as easy as it gets</title>
      <link>http://localhost:1313/post/introducing-hypriot-cluster-lab-docker-clustering-as-easy-as-it-gets/</link>
      <pubDate>Tue, 08 Dec 2015 15:30:00 +0200</pubDate>
      
      <guid>http://localhost:1313/post/introducing-hypriot-cluster-lab-docker-clustering-as-easy-as-it-gets/</guid>
      <description>

&lt;p&gt;Today we wanna share something with you that we have been working on for the last couple of weeks. And we are pretty exited about it, too.
It is based on our beloved &lt;a href=&#34;http://blog.hypriot.com/post/get-your-all-in-one-docker-playground-now-hypriotos-reloaded/&#34;&gt;HypriotOS&lt;/a&gt; and makes it dead simple to build Docker clusters.&lt;/p&gt;

&lt;p&gt;Until now it was not exactly easy to get started with Docker clustering.
You would have needed specific knowledge and lots of time to manually configure the cluster and its individual nodes.&lt;/p&gt;

&lt;p&gt;Well, that&amp;rsquo;s now a thing of the past.&lt;/p&gt;

&lt;p&gt;May we introduce to you the newest member of the Hypriot family: &lt;strong&gt;The Hypriot Cluster Lab!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/cluster-lab-release-v01/cluster_lab.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With the &lt;strong&gt;Hypriot Cluster Lab&lt;/strong&gt; it is just a matter of minutes to set up your own personal Docker cluster.
All you need is a couple of Raspberry Pi&amp;rsquo;s - 3, 5, 30 or even 100 - it is up to you - and our Hypriot Cluster Lab SD card image.&lt;/p&gt;

&lt;p&gt;We designed the Cluster Lab to be completely self-configuring, so there is nothing to configure or to set up.
Basically you just need to download our Cluster Lab SD card image and flash it onto a number of SD cards.
Then ensure that all your Pi&amp;rsquo;s have network connectivity, insert the SD cards and switch on power.
Everything else is taken care of automatically by our Cluster Lab.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker Clustering as easy as it gets!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When we started out to develop the Cluster Lab we wanted to be able to create complex Raspberry Pi based clusters with an arbitrary number of nodes.
We wanted to directly jump to deploying all kind of interesting services on top of the cluster instead of being concerned with setting up the cluster itself.&lt;/p&gt;

&lt;p&gt;And well - we managed to pull this off by combining a number of great technologies.
For instance &lt;strong&gt;Avahi&lt;/strong&gt; for announcing/managing who is a master and who is a slave node in the cluster. &lt;strong&gt;VLAN&lt;/strong&gt; for isolating the cluster network from other existing networks.
&lt;strong&gt;DHCP&lt;/strong&gt; for automatically assigning IP addresses to slave nodes in the cluster network. &lt;strong&gt;Consul&lt;/strong&gt; as a service registry and key-value-store.
And of course a number of other Docker related technologies that we already provide in HypriotOS: &lt;strong&gt;Docker Engine&lt;/strong&gt;, &lt;strong&gt;Swarm&lt;/strong&gt; and &lt;strong&gt;Compose&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;These technologies work together seamlessly and form what we call the Hypriot Cluster Lab. On top of it we are now able to easily deploy all kind of cluster services.
We have a number of ideas where this can come in handy in the future! Think Kubernetes for instance or Redis cluster.&lt;/p&gt;

&lt;p&gt;The Cluster Lab is still a bit rough around the edges and is more technology preview than production ready software, but we think it demonstrates the basic use case very well and shows the potential.
So for the coming weeks we want to gather feedback and make it more polished and resilient.
After that our main goal is to make it possible that all kind of cluster scenarios can be deployed on top of the Cluster Lab with just one command.
We want to make this possible by providing a kind of plugin-mechanism so that the community can help us in enabling many more interesting cluster use cases.&lt;/p&gt;

&lt;p&gt;The main reason that makes us really excited about the Cluster Lab, is that we think that there is great potential in using it as an educational tool in schools, universities or in commercial trainings.
It can be used to teach about Linux, Networking, Clustering, Microservices and so much more!&lt;/p&gt;

&lt;p&gt;And with the latest member of the Raspberry Pi family - the &lt;a href=&#34;http://swag.raspberrypi.org/collections/pi-zero/products/pi-zero&#34;&gt;Pi Zero&lt;/a&gt; - it got really cheap to have your own cluster. For about 50 bucks you are able to have a two to three node physical cluster.
And believe us - having physical nodes and being able to pull the network or power to simulate different cluster scenarios makes all the difference.
Working with &lt;strong&gt;real hardware&lt;/strong&gt; compared to a virtual environment (e.g. Vagrant) &lt;strong&gt;has a certain raw and primal feel about it&lt;/strong&gt; that we really like. :)&lt;/p&gt;

&lt;p&gt;So enough talking - let&amp;rsquo;s get our hands dirty - shall we?&lt;/p&gt;

&lt;h3 id=&#34;prerequisites-or-what-you-gonna-need-to-follow-along:8280d5ff2f6dfae78180ad5a72400c1a&#34;&gt;Prerequisites or what you gonna need to follow along&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;at least two &lt;strong&gt;Raspberry Pi&amp;rsquo;s&lt;/strong&gt;: Model 1 or 2 - both will do&lt;/li&gt;
&lt;li&gt;for each Raspberry Pi a &lt;strong&gt;power supply&lt;/strong&gt;, a &lt;strong&gt;MicroSD card&lt;/strong&gt; and a &lt;strong&gt;network cable&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;a &lt;strong&gt;network switch&lt;/strong&gt; that is somehow connected to the Internet and a DHCP server; both is usually provided by your typical off-the-shelf home router&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, the switch should not filter IEEE 802.1Q VLAN flags out of network packets. Usually this feature is provided even by cheap switches. If you wanna be safe, go through a small test to figure this out. The test is &lt;a href=&#34;https://github.com/hypriot/cluster-lab/blob/master/README.md#troubleshooting&#34;&gt;listed here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;download-flash-boot-enjoy:8280d5ff2f6dfae78180ad5a72400c1a&#34;&gt;Download. Flash. Boot. Enjoy!&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; &lt;strong&gt;Download&lt;/strong&gt; the &lt;a href=&#34;http://downloads.hypriot.com/hypriot_20160121-235123_clusterlab.img.zip&#34;&gt;Hypriot Cluster Lab SD card image&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; Flash the image to your SD cards your way or use &lt;a href=&#34;https://github.com/hypriot/flash&#34;&gt;our funky flash script&lt;/a&gt; which makes flashing the SD cards so much easier.&lt;/p&gt;

&lt;p&gt;Another advantage of our flash script is that it also allows you to give your cluster nodes unique hostnames:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ flash --hostname cl-master http://downloads.hypriot.com/hypriot_20160121-235123_clusterlab.img.zip
$ flash --hostname cl-node-1 http://downloads.hypriot.com/hypriot_20160121-235123_clusterlab.img.zip
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; Put the freshly flashed SD cards in each node&amp;rsquo;s SD card slot.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; Power on &lt;strong&gt;only one&lt;/strong&gt; node. This node will automatically become the master node of the cluster. It might take up to two minutes until the master node is fully functional.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; Find out the IP address of your master node. One way to do this is via &lt;a href=&#34;https://nmap.org/&#34;&gt;nmap&lt;/a&gt; and is described &lt;a href=&#34;http://blog.hypriot.com/getting-started-with-docker-and-linux-on-the-raspberry-pi/#ensure-everything-works:8814904f208dcaade82991443c7514e0&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; Use the IP (from step 5) or the hostname (from step 2) to point your browser to &lt;code&gt;http://{IP or hostname of the master node}:8500&lt;/code&gt;. In our case &lt;code&gt;http://cl-master:8500&lt;/code&gt; opens the Consul web interface and our cluster master node is displayed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/cluster-lab-release-v01/consul_cl_master.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt; Power on all the remaining cluster nodes only if step 5 was successful. After about 2 minutes you should see the rest of them being listed in the Consul web interface, too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/cluster-lab-release-v01/consul_cl_master_and_nodes.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The last step makes the cluster fully operational and we are now able to work with the cluster in earnest.&lt;/p&gt;

&lt;h3 id=&#34;babysteps-with-our-cluster-lab:8280d5ff2f6dfae78180ad5a72400c1a&#34;&gt;Babysteps with our Cluster Lab&lt;/h3&gt;

&lt;p&gt;Congratulations, you got your Hypriot Cluster Lab up and running! That was easy, wasn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;The Cluster Lab is using &lt;a href=&#34;https://docs.docker.com/swarm/&#34;&gt;Docker Swarm&lt;/a&gt; for managing Docker containers on the nodes that make up the cluster.
Docker Swarm will distribute containers based on different distribution &lt;a href=&#34;https://docs.docker.com/swarm/scheduler/strategy/&#34;&gt;strategies&lt;/a&gt; to individual nodes.
Per default Docker Swarm uses the &lt;em&gt;spread&lt;/em&gt; strategy to evenly distribute container on cluster nodes.&lt;/p&gt;

&lt;p&gt;Working with Docker Swarm is easy. To start we first need to log into our cluster master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh root@cl-master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There we can use the Docker Client to connect to the Swarm Manager instance. We do that by providing the &amp;lsquo;-H&amp;rsquo; flag to the &lt;code&gt;docker&lt;/code&gt; command.
This enables the Docker client to use the Docker Remote API for accessing the Swarm Manager.&lt;/p&gt;

&lt;p&gt;To display some basic info about the Swarm Cluster run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 info
Containers: 7
Images: 6
Role: primary
Strategy: spread
Filters: health, port, dependency, affinity, constraint
Nodes: 3
 cl-master: 192.168.200.1:2375
  └ Containers: 3
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.12-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), storagedriver=overlay
 cl-node-1: 192.168.200.115:2375
  └ Containers: 2
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.12-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), storagedriver=overlay
 cl-node-2: 192.168.200.113:2375
  └ Containers: 2
  └ Reserved CPUs: 0 / 4
  └ Reserved Memory: 0 B / 971.8 MiB
  └ Labels: executiondriver=native-0.2, kernelversion=4.1.12-hypriotos-v7+, operatingsystem=Raspbian GNU/Linux 8 (jessie), storagedriver=overlay
CPUs: 12
Total Memory: 2.84
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of the hostname &lt;code&gt;cl-master&lt;/code&gt; one can also use the IP address that is always fixed for the cluster master node: 192.168.200.1.&lt;/p&gt;

&lt;p&gt;Ok - it seems our Swarm cluster is truly up and running.&lt;/p&gt;

&lt;p&gt;Time to get a little bit more daring.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s spin up a web interface for managing our nodes called &lt;a href=&#34;https://github.com/crosbymichael/dockerui&#34;&gt;DockerUI&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker -H cl-master:2378 run -d -p 9000:9000 --env=&amp;quot;constraint:node==cl-master&amp;quot; --name dockerui hypriot/rpi-dockerui -e http://192.168.200.1:2378
51f2eb09ab48540eb4a052bbe07644487c3a0b29ca44a6217ea6aebf17b3df0c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most interesting part here is the env parameter &lt;code&gt;--env=&amp;quot;constraint:node==cl-master&amp;quot;&lt;/code&gt; which tells the Swarm Manager that we want to start our new container on the &lt;strong&gt;cl-master&lt;/strong&gt; node.
Without that the new container would be started by Docker Swarm on one of the nodes according to the &lt;em&gt;spread&lt;/em&gt; strategy.
By using the &amp;lsquo;constraint:node&amp;rsquo; label we are able to control on which node a container gets started.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s open the DockerUI with the following URL: &lt;code&gt;http://cl-master:9000&lt;/code&gt;.
If everything did work you should now see an overview of your running containers similar to this one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/cluster-lab-release-v01/dockerui.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Back to the command line we can see the same result by using the &lt;code&gt;docker ps&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 ps
CONTAINER ID        IMAGE                                                              COMMAND                  CREATED             STATUS              PORTS                          NAMES
51f2eb09ab48        hypriot/rpi-dockerui                                               &amp;quot;./dockerui -e http:/&amp;quot;   12 minutes ago      Up 12 minutes       192.168.200.1:9000-&amp;gt;9000/tcp   cl-master/dockerui
fca75c6b759a        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   About an hour ago   Up About an hour                                   cl-node-2/bin_consul_1
4bfa58ed2a07        hypriot/rpi-swarm                                                  &amp;quot;/swarm join --advert&amp;quot;   About an hour ago   Up About an hour    2375/tcp                       cl-node-2/bin_swarm_1
ec61f8f5d766        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   About an hour ago   Up About an hour                                   cl-node-1/bin_consul_1
75c7cb003639        0104b3a10aad7e9a3d38ca4dce652c73d195b87171675c7dbc114ae85a444831   &amp;quot;/swarm join --advert&amp;quot;   About an hour ago   Up About an hour    2375/tcp                       cl-node-1/bin_swarm_1
df027cd23e69        hypriot/rpi-swarm                                                  &amp;quot;/swarm manage consul&amp;quot;   2 hours ago         Up 2 hours          192.168.200.1:2378-&amp;gt;2375/tcp   cl-master/bin_swarmmanage_1
f6b11e9e4f07        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   2 hours ago         Up 2 hours                                         cl-master/bin_consul_1
8658010a4433        hypriot/rpi-swarm                                                  &amp;quot;/swarm join --advert&amp;quot;   2 hours ago         Up 2 hours          2375/tcp                       cl-master/bin_swarm_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By now you should have gotten the hang of it and come to expect that you can use many of the Docker command line commands with Swarm, too.
And you are right - you just need to remember to use the &lt;code&gt;-H&lt;/code&gt; flag as part of the Docker command.&lt;/p&gt;

&lt;h3 id=&#34;getting-to-the-grown-up-stuff:8280d5ff2f6dfae78180ad5a72400c1a&#34;&gt;Getting to the grown-up stuff&lt;/h3&gt;

&lt;p&gt;After we did our first babysteps successfully it is now time for some serious grown-up stuff.
Certainly Docker multi-host networking can be considered serious stuff - don&amp;rsquo;t you think?&lt;/p&gt;

&lt;p&gt;First let&amp;rsquo;s see if we already have any networks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 network ls
NETWORK ID          NAME                DRIVER
d88253054dd4        cl-node-1/none      null
e78f9fc77a31        cl-node-2/bridge    bridge
12d2cb0e387d        cl-node-2/none      null
020bdb74ea43        cl-node-1/host      host
b39702828ebf        cl-node-1/bridge    bridge
c24764cf7077        cl-master/host      host
480319fbca22        cl-node-2/host      host
e5d7f7a69313        cl-master/bridge    bridge
7153745ef548        cl-master/none      null
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are the networks that are already present by default.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add our own overlay network:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 network create -d overlay my-net
54583b74b0c5b678678db18b99a1148049640e3c4e6ac6f5cdfa0938b1399f3a
HypriotOS: root@cl-master in ~
$ docker -H cl-master:2378 network ls
NETWORK ID          NAME                DRIVER
7153745ef548        cl-master/none      null
c24764cf7077        cl-master/host      host
54583b74b0c5        my-net              overlay
480319fbca22        cl-node-2/host      host
e5d7f7a69313        cl-master/bridge    bridge
b39702828ebf        cl-node-1/bridge    bridge
d88253054dd4        cl-node-1/none      null
e78f9fc77a31        cl-node-2/bridge    bridge
12d2cb0e387d        cl-node-2/none      null
020bdb74ea43        cl-node-1/host      host
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we now have successfully created our first Docker multi-node overlay network.
This overlay network is really useful. Any container started in this network can talk to any other container in the network by default.&lt;/p&gt;

&lt;p&gt;In order to see how this works we are going to start two containers on different cluster nodes that will talk to each other.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 run -itd --name=webserver --net=my-net --env=&amp;quot;constraint:node==cl-node-1&amp;quot; hypriot/rpi-nano-httpd
378ddbe05781360f57f869f9aec7ad4c2cd703047cb5da11a9a7f395501bc533
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Listing the running containers in our cluster we now have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 ps
CONTAINER ID        IMAGE                                                              COMMAND                  CREATED             STATUS              PORTS                          NAMES
378ddbe05781        hypriot/rpi-nano-httpd                                             &amp;quot;/httpd 80&amp;quot;              26 seconds ago      Up 23 seconds       80/tcp                         cl-node-1/webserver
51f2eb09ab48        hypriot/rpi-dockerui                                               &amp;quot;./dockerui -e http:/&amp;quot;   41 minutes ago      Up 40 minutes       192.168.200.1:9000-&amp;gt;9000/tcp   cl-master/dockerui
fca75c6b759a        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   About an hour ago   Up About an hour                                   cl-node-2/bin_consul_1
4bfa58ed2a07        hypriot/rpi-swarm                                                  &amp;quot;/swarm join --advert&amp;quot;   About an hour ago   Up About an hour    2375/tcp                       cl-node-2/bin_swarm_1
ec61f8f5d766        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   About an hour ago   Up About an hour                                   cl-node-1/bin_consul_1
75c7cb003639        0104b3a10aad7e9a3d38ca4dce652c73d195b87171675c7dbc114ae85a444831   &amp;quot;/swarm join --advert&amp;quot;   2 hours ago         Up 2 hours          2375/tcp                       cl-node-1/bin_swarm_1
df027cd23e69        hypriot/rpi-swarm                                                  &amp;quot;/swarm manage consul&amp;quot;   3 hours ago         Up 3 hours          192.168.200.1:2378-&amp;gt;2375/tcp   cl-master/bin_swarmmanage_1
f6b11e9e4f07        hypriot/rpi-consul                                                 &amp;quot;/consul agent -serve&amp;quot;   3 hours ago         Up 3 hours                                         cl-master/bin_consul_1
8658010a4433        hypriot/rpi-swarm                                                  &amp;quot;/swarm join --advert&amp;quot;   3 hours ago         Up 3 hours          2375/tcp                       cl-master/bin_swarm_1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything so far looks good. So let&amp;rsquo;s get the final piece working by starting a web client that talks to our webserver.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker -H cl-master:2378 run -it --rm --net=my-net --env=&amp;quot;constraint:node==cl-node-2&amp;quot; hypriot/armhf-busybox wget -O- http://webserver/index.html
Connecting to webserver (10.0.0.2:80)
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;Pi armed with Docker by Hypriot&amp;lt;/title&amp;gt;
  &amp;lt;body style=&amp;quot;width: 100%; background-color: black;&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;main&amp;quot; style=&amp;quot;margin: 100px auto 0 auto; width: 800px;&amp;quot;&amp;gt;
      &amp;lt;img src=&amp;quot;pi_armed_with_docker.jpg&amp;quot; alt=&amp;quot;pi armed with docker&amp;quot; style=&amp;quot;width: 800px&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
-                    100% |*******************************|   304   0:00:00 ETA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see we have been able to spin up a busybox container on another node.
We used it to fetch the index.html page with the &lt;code&gt;wget&lt;/code&gt; command from our webserver container.&lt;/p&gt;

&lt;p&gt;The simplicity of this illustrates how powerful Docker networking has become.
Creating this kind of a setup with - for example &lt;a href=&#34;http://openvswitch.org/&#34;&gt;OpenVSwitch&lt;/a&gt; - was way more complicated in the past.&lt;/p&gt;

&lt;p&gt;It is possible to create far more complex scenarios with our Cluster Lab, but hopefully we were able to demonstrate a bit of the potential it has.
We will write more about those in some future blog posts.&lt;/p&gt;

&lt;p&gt;Until then we hope that it was fun to follow along and that we could infect you a little bit with our passion for Docker clustering.&lt;/p&gt;

&lt;p&gt;You can find the source code of the Hypriot Cluster Lab at &lt;a href=&#34;https://github.com/hypriot/cluster-lab&#34;&gt;Github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As always, use the comments below to give us feedback, discuss this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=10696752&#34;&gt;HackerNews&lt;/a&gt; and share this post on Twitter, Google or Facebook.&lt;/p&gt;

&lt;p&gt;Andreas &amp;amp; Mathias&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>